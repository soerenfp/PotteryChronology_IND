---
title: "INDPotteryChronology_Statistics"
author: "Soren Pedersen"
date: "20/09/2024"
output: html_document
---

###THIS IS THE MARKDOWN DOCUMENT OF THE STATISTICS OF THE IND POTTERY CHRONOLOGY
  #PhD thesis of Soren Feldborg


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Setup folder sturcture

```{r, echo=TRUe}

#install devtools

#install.packages("devtools")
library(devtools)

#install.packages("rrtools")
library(rrtools)

#You need the "remotes" package to install the "rrtools:BenMarwick" package 

#install.packages("remotes")
library(remotes)

remotes::install_github("benmarwick/rrtools")

#NOTE: I did install ALL updates

#devtools::install_github("benmarwick/rrtools")
---------------------------------------------------------------------------------------
  
#Create a new .Rproj -> very important not to have spaces, underscores or numbers in the folder name
  
#OBS: do not make a new .Rproj if you already have a project running -> skip to next step

#rrtools::use_compendium("C:/Users/Pedersen/Documents/R/PotteryChronologyIND")

#rrtools::use_compendium("C:/Users/Pedersen/Documents/R/RSeminar")


#Example: rrtools::use_compendium("C:/your/path/name/here/YourNewRProjectNameHere")

```

#Set up folder structure

This is to create folder "analysis" with sub-folder structure -> VERY USEFUL

The structure is made by Ben Marwick and is designated for archaeological writing and structure

```{r, echo=TRUE}
#Package that includes folder structure
library(rrtools)

#create folder -> creates the analysis folder and the structure
use_analysis()

#Do this below (pops-up when you execute use_analysis())

#Next, you need to:  ↓ ↓ ↓ ↓ 
#* Write your article/report/thesis, start at the paper.Rmd file
#* Add the citation style library file (csl) to replace the default provided here, see https://github.com/citation-style-language/
#* Add bibliographic details of cited items to the 'references.bib' file
#* For adding captions & cross-referencing in an Rmd, see https://bookdown.org/yihui/bookdown/
#* For adding citations & reference lists in an Rmd, see http://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html
```

#Clean spreadsheet before loading into R

Cleaning a spreadsheet before loading it into R is an important step to ensure your data analysis is accurate and efficient. Here are some key steps you can follow to clean your spreadsheet:

1. Remove Unnecessary Data (done in excel sheet and r)
  - Delete Extra Rows/Columns: Remove any rows or columns that are not relevant to        your analysis, such as empty rows or columns, headers that repeat, or any             irrelevant metadata.
  - Trim Whitespace: Remove any leading or trailing spaces in your cells.

2. Standardize Formats (done in excel sheet)
  - Date Formats: Ensure all date entries are in a consistent format (e.g.,               YYYY-MM-DD).
  - Numeric Formats: Make sure numeric columns do not have any non-numeric characters     (like commas or dollar signs).
  - Text Consistency: Standardize text entries (e.g., capitalization, spelling, etc.).

3. Handle Missing Values (done in r)
  - Identify Missing Values: Use functions to highlight or mark missing values.
  - Decide on a Strategy: Decide whether to remove rows with missing values, fill them     in with a specific value (like the mean or median), or use other imputation             techniques.

4. Correct Data Entry Errors (not done)
  - Identify Duplicates: Check for and remove duplicate rows if necessary.
  - Fix Inconsistencies: Look for typos or inconsistencies in categorical data (e.g.,     “male” vs. “Male”).

5. Transform Data if Necessary (not done)
  - Reformat Data Types: Ensure that each column has the correct data type (e.g.,         factors for categorical data, numeric for quantitative data).
  - Create New Columns: If necessary, create new columns for calculations or derived      values.

6. Document Changes (done, see above parenthesis)
  - Keep a record of the changes made to your spreadsheet for transparency and            reproducibility.

7. Save Your Cleaned Data (done, saved as .xlsx)
  - Save your cleaned spreadsheet in a compatible format (like CSV or Excel) for easy     import into R.
  
#Import excel file into a dataset and clean the dataset

Explanation of the Code:

- Loading Libraries: 
    Ensure that you have the required libraries installed and loaded.

- Reading Data: 
    The read_excel function is used to read the data from the Excel file.

- Data cleaning:
    Replace missing values with NAs
    Trim whitespaces in the excel sheet

- Saving Cleaned Data: 
    Optionally, save the cleaned dataset back to an Excel file using write.xlsx() from     the openxlsx package (you'll need to install that package as well).

```{r, echo=TRUE}
### Load excel sheet into a dataset, trim whitespaces and replace missing rows with NAs

# Install necessary packages
#install.packages("readxl")
#install.packages("dplyr")
#install.packages("stringr")
#install.packages("tidyr")
#install.packages("openxlsx")

# Load necessary packages
library(readxl)   # For reading Excel files
library(dplyr)    # For data manipulation
library(stringr)  # For string operations
library(tidyr)    # For missing values operation
library(openxlsx) # For writing Excel files

# Step 1: Load the Excel file
data_trial02 <- read_excel("analysis/data/raw_data/timeline_data_trial02.xlsx")

# Step 2: View the initial structure of the data
#str(data_trial02)

# Step 3: Handle missing values
# Here, we're filling missing values with NA (default behavior)
# You can also replace them with specific values or remove rows.
data_trial02 <- data_trial02 %>%
  mutate(across(everything(), ~ replace_na(., NA)))  # Fill with NA (optional)

# Step 4: Trim whitespaces from all character columns
data_trial02_trimmed <- data_trial02 %>%
  mutate(across(where(is.character), ~ str_trim(.)))  # Trim whitespace

# View the cleaned data
#head(data_trial02_trimmed)

# Step 5: Save the cleaned data to a new Excel file
write.xlsx(data_trial02_trimmed, "analysis/data/raw_data/data_trial02_trimmed.xlsx")

### Your dataset is now saved as "data_trial02_trimmed.xlsx" in the raw_data folder
```

#Make cluster analysis of the main "actural_width" category dependent on "type_category"

To analyze clusters of Actual width within each numeric category of the Type category (ignoring the letter part, such as 1a, 1b, 1c grouped as 1), we can split the data by the numeric portion of the Type category and then perform clustering on Actual width measurements within each group. Here’s how to do it:

# STEP 1: change the type_cateogry so "1a" becomes "1"

Extract the Numeric Portion of Type Category: Use regular expressions to isolate the numeric part of each Type category value.

```{r, echo=TRUE}
##Step 1: Load Data and Extract Numeric Category

# Used library calls:
#library(dplyr)
#library(readxl)

# Extract numeric part of type_category (e.g., "1a" becomes "1")
data_trial02_typesplit <- data_trial02_trimmed %>%
  mutate(numeric_category = as.numeric(gsub("[^0-9]", "", `type_category`)))

# View the typeslit dataset (optional)
#head(data_trial02_typesplit)

### You have now created a dataset "data_trial02_typesplit" with an extra column named "numeric_category" where the "type_category" has deleted the letter value in the type (i.e. "1a" becomes "1")
```

# Step 2: remove 0s but keep NAs

```{r, echo=TRUE}

# load libraries
#library(dplyr)
#library(ggplot2)
#library(cluster)
#library(readxl)

# Remove rows where actual_width is 0 (keeping NAs)
data_trial02_remove0 <- data_trial02_typesplit %>%
  filter(actual_width != 0 | is.na(actual_width))

```

# STEP 3: prepare the data

```{r, echo=TRUE}

# Load necessary libraries
library(dplyr)
library(ggplot2)
library(cluster)
library(readxl)

# Data preparation (keep only the "numeric_category" and "actual_width")
data_trial02_prep <- data_trial02_remove0 %>%
  select(numeric_category, actual_width) %>%
  mutate(numeric_category = as.factor(numeric_category))

# Normalize the actual_width (optional but recommended)
#data$actual_width <- scale(data$actual_width, center = TRUE, scale = TRUE)

# Convert categorical variable to numeric for clustering
data_trial02_numeric <- data_trial02_prep %>%
  mutate(numeric_category = as.numeric(as.character(numeric_category)))

# Remove rows with NA values for clustering
data_trial02_clustering <- data_trial02_numeric %>%
  filter(!is.na(numeric_category) & !is.na(actual_width))

## You have now created a dataset (data_trial02_clustering) ready for the cluster analysis, only containing the "numeric_category" and "actual_width" rows and cleaned them from 0s and NAs
```

# STEP 4: Perform a cluster analysis

To perform a cluster analysis between "numeric_category" and "actual_width" in your dataset (data_trial02_typesplit), you can follow these general steps in R:

1)Load Necessary Libraries: Ensure you have the necessary packages installed and loaded. Common packages for clustering include dplyr, ggplot2, and cluster.

2) Data Preparation: Prepare your data by ensuring that both numeric_category and actual_width are in the appropriate format for clustering.

3) Data Normalization: It can be beneficial to normalize your data, especially if the scale of actual_width differs significantly from numeric_category.

4) Clustering: Choose a clustering method, such as K-means or hierarchical clustering, to identify clusters.

5) Visualization: Visualize the clusters to see how actual_width relates to numeric_category.

```{r, echo=TRUE}
# install and load libraries

#install.packages("ggplot2")
#install.packages("cluster")
#install.packages("readxl")

library(dplyr)
library(ggplot2)
library(cluster)
library(readxl)

# Choose a number of clusters (e.g., k = 3 -> you can change this later)
set.seed(123)  # For reproducibility
k <- 3
kmeans_result <- kmeans(data_trial02_clustering[, c("numeric_category", "actual_width")], centers = k)

# Add cluster assignments back to the original dataset
# Ensure the cluster assignment only goes to rows without NAs
data_trial02_clustering$cluster <- NA  # Initialize the column with NAs
data_trial02_clustering$cluster[!is.na(data_trial02_clustering$numeric_category) & !is.na(data_trial02_clustering$actual_width)] <- as.factor(kmeans_result$cluster)

# Check that cluster assignments were added correctly
#summary(data_trial02_clustering$cluster)
```

# Visualize the cluster plot

```{r, echo=TRUE}

# Visualize the clusters
ggplot(data_trial02_clustering, aes(x = numeric_category, y = actual_width, color = cluster)) +
  geom_point() +
  labs(title = "Cluster Analysis of Actual Width by Numeric Category",
       x = "Numeric Category",
       y = "Actual Width") +
  theme_minimal()

```

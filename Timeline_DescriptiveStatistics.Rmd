---
title: "Timeline_DescriptiveStatistics"
author: "Soren Pedersen"
date: "2024-11-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. 

--------------------------------------------------------------------------------

### IDEAS FOR THIS DOCUMENT ###

Interpret the key results for Display Descriptive Statistics

Step 1: Describe the size of your sample.
Step 2: Describe the center of your data.
Step 3: Describe the spread of your data.
Step 4: Assess the shape and spread of your data distribution.

Compare data from different groups.

To better understand my data I have made a document to explore the data:

- which rim type is most popular overall? -DONE-
- which rim type is most popular per site? -DONE-
- which rim type is most popular through time?

- which base type is most popular overall? -DONE-
- which base type is most popular per site? -DONE- (but not as three plots)
- which base type is most popular through time?

- Which vessel type is most dominant overall? -DONE-
- Which vessel type is most dominant per site? -DONE-
- Which vessel type is most dominant through time?

- What size category is dominant overall? -DONE-
- What size category is dominant per site? -DONE- (but not as three plots)
- What size category is dominant through time?

- What attribute category is dominant overall? -DONE-
- What attribute category is dominant per site?
- What attribute category is dominant through time?

- What decoration category is dominant overall?
- What decoration category is dominant per site?
- What decoration category is dominant through time?

- Calculate the mean, median, range (min./max.), and standard deviation (SD) for each vessel type based on:
  - actual_width -DONE-
  - actual_height -DONE-
  - actual_diameter -DONE-
- Plot each parameter in bar plots -DONE-

-----------------------------------------
### STEP 0: Install and load packages ###
-----------------------------------------

```{r, echo=TRUE}

# Install necessary packages:

# install.packages("readxl")    # For reading Excel files
# install.packages("dplyr")
# install.packages("ggplot2")
# install.packages("factoextra") # For visualizing clusters
# install.packages("cluster")
# install.packages("cowplot")
# install.packages("tidyr")
# install.packages("stringr")
# install.packages("openxlsx")
# install.packages("vcd")
# install.packages("reshape2")
# install.packages("devtools")
# install.packages("rrtools")
# install.packages("remotes")
# install.packages("viridis")
# install.packages("ggrepel")
# install.packages("tidyverse")
# install.packages("plotly")
# install.packages("ggforce")
# install.packages("fs")
# install.packages("cli")
# install.packages(c("devtools", "cli", "fs", "rlang", "glue", "lifecycle"))


# Load necessary libraries:

library(cli)
library(fs)
library(devtools)
library(remotes)
library(readxl)
library(dplyr)
library(ggplot2)
library(factoextra)
library(cluster)
library(cowplot)
library(tidyr)
library(stringr)
library(openxlsx)
library(vcd)
library(reshape2)
library(viridis)
library(ggrepel)
library(tidyverse)
library(plotly)
library(ggforce)
```

--------------------------------------------------------------------------------
# STEP 0: Load data (Skip if you have already loaded the data in previous steps)
--------------------------------------------------------------------------------

# Load data

The data is named data_measurements01.xlsx from the previous step. 

```{r, echo=TRUE}

# Load your dataset from an Excel file
ceramics_data <- read_excel("analysis/data/raw_data/data_measurements_01.xlsx")

#Make 0.0 values into NAs for the actual_width, actual_diameter, and actual_height columns
ceramics_data <- ceramics_data %>%
  mutate(across(c(actual_width, actual_diameter, actual_height), ~na_if(.x, 0)))

# Ensure your Excel file has columns: actual_diameter, actual_width, actual_height
# Check the first few rows of your data
head(ceramics_data)

```


-----------------------------------------------------
# STEP 1: Make a dataset for the descriptive analysis
-----------------------------------------------------

- I made a new data set only including the "site_name", "type_category", "size_category", ""rim_category", "base_category", "attributes", "actual_diameter", "actual_height", "actual_width"
- (NOT: I removed rows with missing values in the "actual_diameter" column (registered as 0.0 in the excel sheet))
- This dataset it used for making the following "nice" boxplots!

```{r, echo=TRUE}
ceramics_subset <- ceramics_data %>%
#  filter(actual_diameter != 0.0) %>%   #Only filter the 0,0s later!
  select(site_name, type_category, size_category, rim_category, base_category, 
         att_category, actual_diameter, actual_height, actual_width)

```

So, now I created a data set "ceramics_subset" of the columns noted above (NOT: and removed rows from the "actual_diameter" column that contained 0.0 values). Tha dataset still contains the original 611 vessels.

---------------------------------------------------------
# Step 2: Boxplot of data points per vessel type category
---------------------------------------------------------

```{r, echo=TRUE}
# Used libraries
#library(ggplot2)

# Barplot of 'Counts per Type Category' 

# Drop NAs and count data points per type category
summary_counts_vessel <- ceramics_data %>%
  drop_na(type_category) %>%
  count(type_category, name = "Count")

# Calculate total number of data points (all rows after removing NAs)
total_points_vessel <- nrow(ceramics_data %>% drop_na(type_category))

# Plot the counts with total as a label inside the plot
ggplot(summary_counts_vessel, aes(x = type_category, y = Count)) +
  geom_bar(stat = "identity") +
  annotate("text", x = Inf, y = Inf, label = paste("Total:", total_points_vessel),
           hjust = 1.1, vjust = 2, size = 5, fontface = "bold", color = "black") +
  labs(
    x = "vessel type Category",
    y = "Count",
    title = "Counts per Type Category"
  ) +
  theme_minimal()

```
Very nice!

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each vessel type
vessel_counts <- data.frame(table(ceramics_subset$type_category))   #make a data set of type_category and the counts per category
colnames(vessel_counts) <- c("type_category", "count")    #name the columns in vessel_counts

# Calculate total number of data points
total_vessels <- sum(vessel_counts$count)

# Create the bar plot of 'Data points per vessel type'
bar_plot_vessel <- ggplot(vessel_counts, aes(x = as.factor(type_category), y = count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Vessel Type",
       x = "Vessel Type",
       y = "Number of Data Points") +
  annotate("text", 
           x = Inf, y = Inf, 
           label = paste("Total =", total_vessels), 
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for vessel type descriptions
legend_table_vessel <- data.frame(
  type_category = 1:15,
  Description = c("Wide-open sphere", "Open sphere", "Closed hor. ellipsoid", 
                  "Vertical sphere", "Closed sphere", "Tightly-closed sphere", 
                  "Open carinated", "Wide-open carinated", 
                  "Vertical ver. ellipsoid", "Closed ver. ellipsoid", 
                  "Tightly-closed ver. ellipsoid", "Lids", 
                  "Flasks", "Tellem tripods", "Tellem tripods (top)")
)

# Convert the legend table to a plot with adjusted margins
legend_plot_vessel <- ggplot(legend_table_vessel, aes(x = "", y = type_category, label = paste(type_category, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side
cowplot::plot_grid(bar_plot_vessel, legend_plot_vessel, ncol = 2, rel_widths = c(3, 1.5))

```
This plot looks nice! It includes all the 611 vessels.

NIck (DONE): You need a barplot here, change geom_boxplot() to geom_bar()

# PRELIM interpretation:

- Vessel category 5 (closed vessels) has by far the most data points -> interesting because it also has the most multi purpose function!!!
- 2nd most data point are vessel category 4 (vertical vessels) -> also interesting because I think this is also a very multi purpose vessel!!!
- 3rd most data point are vessel category 2 (open vessels)
- 4th most data point are vessel category 7 (Open carinated vessels)
- 5th most data point are vessel category 1 (wide-open vessels)
- 6th most data point are vessel category 15 (Tellem tripods)
- 7th and 8th most data point are vessel category 3 (closed horizontal-oval vessels) and 10 (closed vertical-oval vessels)
- 9th most data point are vessel category 6 (tightly-closed vessels)
- 10th most data point are vessel category 8 (wide-open carinated vessels)
- 11th most data point are vessel category 9 (Vertical vertical-oval vessels)
- 12th most data point are vessel category 11 (tightly-closed vertical oval vessels)
- 13th most data point are vessel category 14 (bottles)
- 14th most data point are vessel category 13 (flasks)
- vessel category 12 is left out because there are no data points (lids)

- There is actually a correlation between how "multi-purpose" a vessel is and the amount of data points I have collected. The "closed vessels", "vertical vessels" and the "open vessels" are the three categories you can describe as the most multi-purpose!

-NICK/me: this also points to the conservationism of the pottery, in where the oldest forms are also the most numerous. They do not change the pottery types so often!

---------------------------------------------------------------
# STEP 3: Barplot of how many datapoint I have per rim category
---------------------------------------------------------------

```{r, echo=TRUE}
# Used libraries
#library(ggplot2)

# Barplot of 'Counts per Rim Category' 

# Drop NAs and count data points per rim category
summary_counts_rim <- ceramics_data %>%
  drop_na(rim_category) %>%
  count(rim_category, name = "Count")

# Calculate total number of data points (all rows after removing NAs)
total_points_rim <- nrow(ceramics_data %>% drop_na(rim_category))

# Plot the counts with total as a label inside the plot
ggplot(summary_counts_rim, aes(x = rim_category, y = Count)) +
  geom_bar(stat = "identity") +
  annotate("text", x = Inf, y = Inf, label = paste("Total:", total_points_rim),
           hjust = 1.1, vjust = 2, size = 5, fontface = "bold", color = "black") +
  labs(
    x = "Rim Category",
    y = "Count",
    title = "Counts per Rim Category"
  ) +
  theme_minimal()

```

Let's try to make the plot nicer

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each vessel type
rim_counts <- data.frame(table(ceramics_data$rim_category))
colnames(rim_counts) <- c("rim_category", "Count")

# Calculate total number of rim data points
total_rims <- sum(rim_counts$Count)

# Create the bar plot of 'Data points per vessel type' with total count
bar_plot_rim <- ggplot(rim_counts, aes(x = as.factor(rim_category), y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Rim Type",
       x = "Rim Type",
       y = "Number of Data Points") +
  annotate("text", 
           x = Inf, y = Inf, 
           label = paste("Total =", total_rims), 
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for vessel type descriptions
legend_table_rim <- data.frame(
  Rim_Type = 1:27,
  Abbreviation = c("Sr", "Sp", "Sf", "Sb", "Es", "Ec", "Ecc", "Ef", "Efl", "Ep", 
                   "Et", "Esg", "Emg", "Vs", "Vc", "Oth", "Otc", "Otf", "Ith", 
                   "Itc", "Itf", "Th", "Tc", "Tf", "Ca", "B", "Y"),
  Description = c("Simple, rounded", "Simple, pointy", "Simple, flattened", 
                  "Simple, bevelled", "Everted, simple", "Everted, collared", 
                  "Everted, collared channelled", "Everted, flaring", 
                  "Everted, flattened", "Everted, protruding", 
                  "Everted, thickened", "Everted, single groove", 
                  "Everted, multiple groove", "Vertical, simple", "Vertical, collared", 
                  "Outward thickened, hinged", "Outward thickened, curved", 
                  "Outward thickened, flattened", "Inwards thickened, hinged",
                  "Inwards thickened, curved", "Inwards thickened, flattened",
                  "Thickened, hinged", "Thickened, curved", "Thickened, flattened",
                  "Carinated", "Backward rims", "Y-rims")
)

# Convert the legend table to a plot with adjusted margins and abbreviations
legend_plot_rim <- ggplot(legend_table_rim, aes(x = "", y = Rim_Type, label = paste(Abbreviation, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side with adjusted widths
cowplot::plot_grid(bar_plot_rim, legend_plot_rim, ncol = 2, rel_widths = c(3, 1.5))

```
So, this looks damn good! 

# PRELIM interpretation of trial data:

- The Sr (Simple Rounded) category is by far the most represented, as expected! Perhaps you can also say that this category is very multi-purpose because it does not include or exclude any functions?

- The Es (Everted Simple) category is the 2nd highest represented. This is also one of the earliest categories of rims (after the Sr, and 'thickened' categories). This rim category is for handling the vessel, to fasten a cloth and string around to close the vessel, or to pour from.

- The Otc (Outwards Thickened, curved) is the 3rd highest category and also the 2nd earliest rim type - if I remember correctly! This type is for handling the vessel (not hot vessel!), close the vessel with string and cloth, or to reinforce the rim.

- The Itc (Inwards Thickened, curved) is the 4th highest category. This category is also for handling the vessel or to reinforce the rim.

- The Sf (Simple, flattened) rim are the 5th highest category, and there is perhaps not so much function in this rim. Perhaps you can easier stack the vessels, but I think it is mosly for appearence. 

- The Oth (Outwards thickened, hinged) rims are the 6th highest category, and here the rim is for grabbing or reinforcing the vessel, but because it has a sharp corner under the rim then perhaps it is better suited for closing the vessel with cloth and string. This can also be an over-interpretation and the sharp corner under the rim can be just for aesthetics, or for a better grip?.

- The 7th and 8th highest categories are the Sb (Simple, beveled) and Sp (Simple, pointy) categories. I think these categories are mostly for aesthetics, but there can be some stacking functions in these

- the 9th highest category is the Tc (Thickened, curved) category, where this is for grapping or reinforcing the vessel. 

- The rest of the categories are quite evenly represented!

I want to collapse the different rim categories into more manageable categories. 

```{r, echo=TRUE}

rim_counts_collapsed <- ceramics_data %>%
  filter(!is.na(rim_category)) %>%
  mutate(rim_group = case_when(
    grepl("^S", rim_category) ~ "Simple rims",
    grepl("^E", rim_category) ~ "Everted rims",
    grepl("^V", rim_category) ~ "Vertical rims",
    grepl("^O", rim_category) ~ "Outwards th. rims",
    grepl("^I", rim_category) ~ "Inwards th. rims",
    grepl("^T", rim_category) ~ "Thickened rims",
    grepl("^C", rim_category) ~ "Carinated rims",
    grepl("^B", rim_category) ~ "Backward rims",
    rim_category == "Y" ~ "Y-rims",
    TRUE ~ "Other"
  )) %>%
  group_by(rim_group) %>%
  summarise(Count = n(), .groups = "drop")

# Total number of rim data points
total_rims <- sum(rim_counts_collapsed$Count)

# Bar plot
bar_plot_rim_collapsed <- ggplot(rim_counts_collapsed, aes(x = rim_group, y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Collapsed Rim Type",
       x = "Rim Group",
       y = "Number of Data Points") +
  annotate("text", 
           x = Inf, y = Inf, 
           label = paste("Total =", total_rims), 
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10),
    legend.position = "none"
  )

bar_plot_rim_collapsed

```

Collapsing the data might help understand the rim types!

OBS: I need to work on separating the Inwards thickened category from the Inverted category -> solved! I renamed the inverted rims to backward

----------------------------------------------------------------
# STEP 4: Boxplot of how many datapoint I have per base category
----------------------------------------------------------------

```{r, echo=TRUE}

# Used libraries
#library(ggplot2)
#library(tidyr)

# Boxplot of 'Counts per Base Category' 
ceramics_subset %>% 
  drop_na(base_category) %>%  #Drop NAs in 'base_category'
ggplot(aes(x = base_category)) +
  geom_bar() +
  labs(x = "Base Category", y = "Count", title = "Counts per Base Category") +
  theme_minimal()

```
So, this looks nice !

Let's try to make the plot nicer

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each base type
base_counts <- data.frame(table(ceramics_subset$base_category))
colnames(base_counts) <- c("base_category", "Count")

# Calculate total number of base data points
total_base <- sum(base_counts$Count)

# Create the bar plot of 'Data points per base type' with total count
bar_plot_base <- ggplot(base_counts, aes(x = as.factor(base_category), y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Base Type",
       x = "Base Type",
       y = "Number of Data Points") +
  annotate("text",
           x = Inf, y = Inf,
           label = paste("Total =", total_base),
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for base type descriptions
legend_table_base <- data.frame(
  Base_Type = 1:9,
  Abbreviation = c("Bf", "Br", "Bpe", "Bl", "Bc", "Bpo", "Sp", "Bro", "Bt"),
  Description = c("Bases, flat", "Bases, ring", "Bases, pedestal", 
                  "Bases, legged", "Bases, concave", "Bases, pointy", "Special", 
                  "Bases, rounded", "Bases, tripod")
)

# Convert the legend table to a plot with adjusted margins
legend_plot_base <- ggplot(legend_table_base, aes(x = "", y = Base_Type, label = paste(Abbreviation, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side
cowplot::plot_grid(bar_plot_base, legend_plot_base, ncol = 2, rel_widths = c(3, 1.5))

```
So, this plot looks nice! It only includes the vessels that have a registered base, so NA's are excluded!

Rounded bases are only included in the registration if the vessel was fully reconstructed

OBS: I need to include the registrations I have from the excavation reports I have in the RAW database in the final presentation!

#PRELIM interpretation of trial data:

- Most of the bases are NA because nothing was registered
- Bpe (Base, pedestalled) are the category with most data points -> in this category we also have the Tellem tripods base - perhaps I need to make a separate category for that!
- Br (Bases, ring) are the 2nd highest category
- Bf (Bases flat) are the 3rd highest category
- Bpo (Bases, pointy) are the 4th highest category
- Bl (Bases, legged) I think only has one count (jenne-jeno)
- Special -> I must find out what is the special category!

----------------------------------------------------------------
# STEP 5: Boxplot of how many datapoint I have per size cateogry
----------------------------------------------------------------

```{r, echo=TRUE}
ceramics_data %>% 
drop_na(size_category) %>% 
ggplot(aes(x = size_category)) +
  geom_bar() +
  labs(x = "Size Category", y = "Count", title = "Counts per Size Category") +
  theme_minimal()
```
Very nice! As expected I have the most vessels in size category "b", but surprising is that the small size category "a" is so dominant.

Let's try to make the plot a little nicer

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each size category
size_counts <- data.frame(table(ceramics_subset$size_category))
colnames(size_counts) <- c("size_category", "Count")

# Calculate total number of size data points
total_size <- sum(size_counts$Count)

# Create the bar plot of 'Data points per size category' with total count
bar_plot_size <- ggplot(size_counts, aes(x = as.factor(size_category), y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Size Category",
       x = "Size Category",
       y = "Number of Data Points") +
  annotate("text",
           x = Inf, y = Inf,
           label = paste("Total =", total_size),
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for size type descriptions
legend_table_size <- data.frame(
  Size_Type = 1:5,
  Abbreviation = c("a", "b", "c", "d", "e"),
  Description = c("<14.9 cm", "15-24.9 cm", "25-34.9 cm", "35-44.9 cm", ">45 cm")
)

# Convert the legend table to a plot with adjusted margins and abbreviations
legend_plot_size <- ggplot(legend_table_size, aes(x = "", y = Size_Type, label = paste(Abbreviation, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side
cowplot::plot_grid(bar_plot_size, legend_plot_size, ncol = 2, rel_widths = c(3, 1.5))


```
So, this looks very nice!

# Interpretation of the 02_timelinedata results

OBS: Remember that the size categories are based on the "actual_width" of the vessels and NOT something like volume

- Surprising that the "a" size category is so dominant. This is perhaps because the small vessels are often dropped or broken?? 14.9 cm (the largest vessels in this category) might be used for cooking also, but by far the most vessels are small short-term storage pots, or perhaps special vessels for casting or salt making??

- As expected, the size category "b" is the most dominant vessel size. In this category you would expect to find the "normal" cooking vessels and vessels that are more or less multi-purpose.

- As expected, the size category "c" is dominant, but only third most dominant after the size "a" groups (slightly). In this category I would expect that many of the "wide-open vessels" are represented, and otherwise many sort- to medium-term storage vessels.

- As expected, the size "d" vessels are not so dominant. In this category I would expect to find the long-term storage vessels, fermenting/brewing vessels, and many of the large "wide-open" vessels.

- As expected, the size cateogry "e" is the least dominant. I this category I would expect to find the very large "wide-open" vessels, and otherwise vessels that are highly specialized like large brewing vessels or special long-term storage vessels (perhaps to be dug into the ground?).

---------------------------------------------------------------------
# STEP 6: Boxplot of how many datapoint I have per attribute cateogry
---------------------------------------------------------------------

Simple boxplot

```{r, echo=TRUE}
ceramics_data %>% 
drop_na(att_category) %>% 
ggplot(aes(x = att_category)) +
  geom_bar() +
  labs(x = "Attribute Category", y = "Count", title = "Counts per Attribute Category") +
  theme_minimal()
```
looks nice! 

I must specify that these attributes are only found on the reconstructed vessels, and more attributes have been registered in the publications -> registered in my second excel sheet

I must also specify that these attributes are only the ones that are suspected to be funcitonal!

Let's make the plot nicer

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each vessel type
attribute_counts <- data.frame(table(ceramics_subset$att_category))
colnames(attribute_counts) <- c("attributes", "Count")

# Calculate total number of attribute data points
total_attributes <- sum(attribute_counts$Count)

# Create the bar plot of 'Data points per attribute' with total count
bar_plot_attribute <- ggplot(attribute_counts, aes(x = as.factor(attributes), y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Attribute Category",
       x = "Attribute Category",
       y = "Number of Data Points") +
  annotate("text",
           x = Inf, y = Inf,
           label = paste("Total =", total_attributes),
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for vessel type descriptions
legend_table_attribute <- data.frame(
  Attribute_Type = 1:5,
  Abbreviation = c("H", "Sp", "St", "K", "Pl"),
  Description = c("Handles", "Spouts", "Steamers", "Knobs", "Plastic Band")
)

# Convert the legend table to a plot with adjusted margins and abbreviations
legend_plot_attribute <- ggplot(legend_table_attribute, aes(x = "", y = Attribute_Type, label = paste(Abbreviation, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side with adjusted widths
cowplot::plot_grid(bar_plot_attribute, legend_plot_attribute, ncol = 2, rel_widths = c(3, 1.5))


```
Looks perfect!

--------------------------------------------------------------------------------
## DATA PER SITE ##
-------------------

---------------------------------------------
# STEP 1: Plot of vessel type counts per site
---------------------------------------------

The following analysis explores which vessel types are dominant per site.

# STEP 01: Plot each site individually with vessel type counts

OBS: "VS01" which is the addition to the data tables I produce refers to "Vessel - Site" and data table 01 (ex: data_count_VS01)

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(dplyr)
#library(viridis)

# Assuming your dataset is named 'ceramics_subset' with columns 'site_name' and 'type_category'
# Count the occurrences of type_category per site
data_count_VS01 <- ceramics_subset %>%
  group_by(site_name, type_category) %>%
  summarise(count = n(), .groups = 'drop')

# Add a mapping of type_category to type descriptions (example mapping)
type_descriptions_VS01 <- data.frame(
  type_category = as.character(1:15),
  type_description = c("1- Wide-open globular", "2- Open globular", "3- Closed hor. oval", "4- Vertical globular", "5- Closed globular", 
                       "6- Tightly-closed globular", "7- Open carinated", "8- Wide-open carinated", "9- Vertical ver. oval", "10- Closed ver. oval", 
                       "11- Tightly-closed ver. oval", "12- Lids (NOT plottet)", "13- Flasks", "14- Bottles", "15- Tellem tripods")
)

# Make sure the "type_category" columns are both character columns
data_count_VS01$type_category <- as.character(data_count_VS01$type_category)
type_descriptions_VS01$type_category <- as.character(type_descriptions_VS01$type_category)

# Merge descriptions into the data
data_count_VS01 <- data_count_VS01 %>%
  left_join(type_descriptions_VS01, by = "type_category")

# Ensure the x-axis (type_category) and legend are in numeric order
data_count_VS01 <- data_count_VS01 %>%
  mutate(type_category = factor(type_category, levels = as.character(1:15)),
         type_description = factor(type_description, levels = type_descriptions_VS01$type_description))

# Create a function to generate a plot for a single site
plot_site_VS01 <- function(site_name) {
  site_data <- data_count_VS01 %>% filter(site_name == !!site_name)
  
  ggplot(site_data, aes(x = type_category, y = count, fill = type_description)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_viridis(discrete = TRUE, option = "D") +
    theme_minimal() +
    labs(
      title = paste("Vessel Types at Site:", site_name),
      x = "Type Category",
      y = "Count",
      fill = "Type Category"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Get unique site names
site_names_VS01 <- unique(data_count_VS01$site_name)

# Generate and print plots for each site
for (site in site_names_VS01) {
  print(plot_site_VS01(site))
}
```

Damn this looks good! But you should determine a specific colour to each vessel shape. Right now it changes from one plot to the next

OBS: Some sites have decimal numbers and I do not really know why. The plots should only represent whole numbers. The sites are: Dhar Tichitt, Dia Mara, Korounkorokale, Sadia.

OBS: You must make a designated colour to the types, right now the colour does not follow the vessel type


# Interpretation of the results (from most to least vessel types)

Akumbu: 10 vessel types are represented, where the dominant is cat. 5, followed by 4 and 6. So, quite many storage vessels at Akumbu

Jenne-jeno: 10 vessel types are represented, where the dominant is cat. 7 the carinated vessels, followed by cat. 5. Also the cat. 1 and 2 vessels are quite numerous, and together the "wide-open" and "open" vessels are very dominant. Does this talk into presenting food and symposiums??? 

Koumbi Saleh: 10 vessel types are represented, where the dominant is cat. 4 followed by 5, 9, 10 (the tall-ovoid types)

T. Doupville/Galia: 10 vessel types are represented where the most dominant is cat. 4 followed by 2, 3, 10. NO vessel cat. 5 (surprise)!

Dangandouloun: 7 vessel types are represented, where the dominant is cat. 15, followed by 5, 4, 6, and 7. Again quite many storage vessels

Dia Shoma: 7 vessel types are represented, where the dominant is cat. 3 and 10.

Gao Saney: 7 vessel types are represented, where the dominant is cat. 2 the open vessels (surprise?), followed by cat. 4 and 5

Winde Koroji: 7 vessel types are represented where the most dominant is cat. 4, followed by 3, 5. 

KNTII: 6 vessel types are represented, where the dominant is cat. 5 followed by 4. 

Karkarichinkat: 6 vessels are represented, where the dominant is cat. 5 followed by 2. Quite many cat. 6 sotrage vessels are also represented

Pegue A: 6 vessel types are represented, where the dominant is cat. 5 followed by 15 and 4 (many Tellem tripods -> site specialization?)

Timbuktu: 6 vessel types are represented, where the dominant is cat. 5 followed by 7 and 4

Kobadi: 5 vessel types are represented, where the dominant is cat. 5 followed by 1 and 4

Ounjougou: 5 vessels are represented, BUT there is a problem that the site is presented from 3 timeslizes. The most dominant is cat. 4

Sadia: 5 vessel types are represented, where the most dominant is cat. 5 followed by 4

Toubel: 5 vessel types are represented where the dominant is cat. 5 followed by 2.

Dia Mara: 4 vessel types are represented, but NO number 5. No dominant vessel type

Dourou-boro: 4 vessel types are represented, where the two dominant are cat. 4 and 5

Dhar Tichitt: 3 vessel types are represented where the dominant is cat. 5

Korounkorokale: 3 vessel types are represented, where the dominant is cat. 4

Mema: 3 vessel types are represented, where the dominant is cat. 5

OBS: I need to divide them into time phases, because right now I only see all the phases represented in one plot. I need to think about that.

So, there is a difference of how many vessel types are represented at the sites, where Akumbu, Jenne-jeno, Koumbi Saleh, and T. Doupville/Galia all have 10 vessel types at the most. What is common from these sites? I think they are all hubs and "urbanized" but is there something else in common???

# STEP 02: Plot all the sites in three diagrams with the different vessel types represented

OBS: "VS02" which is the addition to the data tables I produce refers to "Vessel - Site" and datatable 02 (ex: data_count_VS02)

The plots are so large that I need to print them in three plots

#Prepare data for three plots

```{r, echo=TRUE}

# Assuming your dataset is named 'ceramics_subset' with columns 'site_name' and 'type_category'
# Count the occurrences of type_category per site
data_count_VS02 <- ceramics_subset %>%
  group_by(site_name, type_category) %>%
  summarise(count = n(), .groups = 'drop')

# Add a mapping of type_category to type descriptions (example mapping)
type_descriptions_VS02 <- data.frame(
  type_category = as.character(1:15),
  type_description = c("1- Wide-open globular", "2- Open globular", "3- Closed hor. oval", "4- Vertical globular", "5- Closed globular", 
                       "6- Tightly-closed globular", "7- Open carinated", "8- Wide-open carinated", "9- Vertical ver. oval", "10- Closed ver. oval", 
                       "11- Tightly-closed ver. oval", "12- Lids (NOT plotted)", "13- Flasks", "14- Bottles", "15- Tellem tripods")
)

# Ensure the type_category columns are both character columns
data_count_VS02$type_category <- as.character(data_count_VS02$type_category)
type_descriptions_VS02$type_category <- as.character(type_descriptions_VS02$type_category)

# Merge descriptions into the data
data_count_VS02 <- data_count_VS02 %>%
  left_join(type_descriptions_VS02, by = "type_category")

# Ensure the x-axis (type_category) and legend are in numeric order
data_count_VS02 <- data_count_VS02 %>%
  mutate(type_category = factor(type_category, levels = as.character(1:15)),
         type_description = factor(type_description, levels = type_descriptions_VS02$type_description))

# Pivot the data to wide format: Each type_category becomes a separate column
data_wide_VS02 <- data_count_VS02 %>%
  select(-type_description) %>% # Exclude type_description for the wide format
  pivot_wider(names_from = type_category, values_from = count, values_fill = list(count = 0))

# Reshape the data back to long format for plotting
data_long_VS02 <- data_wide_VS02 %>%
  pivot_longer(cols = -site_name, names_to = "type_category", values_to = "count") %>%
  mutate(type_category = factor(type_category, levels = as.character(1:15))) # Restore factor order

# Merge back the type descriptions for plotting
data_long_VS02 <- data_long_VS02 %>%
  left_join(type_descriptions_VS02, by = "type_category")

```

#Make data tables for three plots

```{r, echo=TRUE}

# Split the data into three halves based on the site_name
third_size_VS02 <- floor(n_distinct(data_long_VS02$site_name) / 3)
site_names_first_third_VS02 <- unique(data_long_VS02$site_name)[1:third_size_VS02]
site_names_second_third_VS02 <- unique(data_long_VS02$site_name)[(third_size_VS02 + 1):(2 * third_size_VS02)]
site_names_third_third_VS02 <- unique(data_long_VS02$site_name)[(2 * third_size_VS02 + 1):length(unique(data_long_VS02$site_name))]

# Subset the data for each third of site names
data_first_third_VS02 <- data_long_VS02 %>%
  filter(site_name %in% site_names_first_third_VS02)

data_second_third_VS02 <- data_long_VS02 %>%
  filter(site_name %in% site_names_second_third_VS02)

data_third_third_VS02 <- data_long_VS02 %>%
  filter(site_name %in% site_names_third_third_VS02)

# Ensure numeric order for type_category and include descriptions
data_first_third_VS02 <- data_first_third_VS02 %>%
  mutate(
    type_category = factor(type_category, levels = as.character(1:15)),
    type_description = factor(type_description, levels = type_descriptions_VS02$type_description)
  )

data_second_third_VS02 <- data_second_third_VS02 %>%
  mutate(
    type_category = factor(type_category, levels = as.character(1:15)),
    type_description = factor(type_description, levels = type_descriptions_VS02$type_description)
  )

data_third_third_VS02 <- data_third_third_VS02 %>%
  mutate(
    type_category = factor(type_category, levels = as.character(1:15)),
    type_description = factor(type_description, levels = type_descriptions_VS02$type_description)
  )

# Plot 1: First third of the sites
plot1_VS02 <- ggplot(data_first_third_VS02, aes(x = site_name, y = count, fill = type_description)) +
  geom_bar(stat = "identity", position = "dodge") +  # Position bars side by side
  scale_fill_viridis(discrete = TRUE, option = "D") +  # Viridis palette
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Vessel Type Categories pr. Site (1/3)",
    fill = "Type Description"  # Updated legend title
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Plot 2: Second third of the sites
plot2_VS02 <- ggplot(data_second_third_VS02, aes(x = site_name, y = count, fill = type_description)) +
  geom_bar(stat = "identity", position = "dodge") +  # Position bars side by side
  scale_fill_viridis(discrete = TRUE, option = "D") +  # Viridis palette
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Vessel Type Categories pr. Site (2/3)",
    fill = "Type Description"  # Updated legend title
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Plot 3: Third third of the sites
plot3_VS02 <- ggplot(data_third_third_VS02, aes(x = site_name, y = count, fill = type_description)) +
  geom_bar(stat = "identity", position = "dodge") +  # Position bars side by side
  scale_fill_viridis(discrete = TRUE, option = "D") +  # Viridis palette
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Vessel Type Categories pr. Site (3/3)",
    fill = "Type Description"  # Updated legend title
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#Print the three plots

```{r, echo=TRUE}
# Print plot1_VS
plot1_VS02
```

```{r, echo=TRUE}
# Print plot2_VS
plot2_VS02
```

```{r, echo=TRUE}
# Print plot3_VS
plot3_VS02
```
OK! These three plots look nice! 

- I need to plot each site before showing these three plots
- I need to change the name of Togue Doupville-Galia to T. Doupville-Galia in the spreadsheet for better fit

# Interpretaiton of the 02_timelinedata results

- When there are many of one vessel type pr. site: 
  -> does that mean that the site was quite highly specialized like Pegue A and Dangandouloun that has a lot of the 15 Tellem tripods?
  -> does it mean that the site was early and only had a few pottery shapes available?
  -> does it mean that the site was specialized as hunting stations or seasonal?
  -> is it because the site has a short life span or narrow dating?
  
- When there are many of several vessels pr. site:
  -> does that mean that the site was a hub or "urban" site? (eg. many different cultural groups bring their own pottery types with them)
  -> does it mean that the site had developed a large array of pottery types "in situ" because it was dominant? (to "monopolize" the area culturally)
  -> does it mean that many different productions (metal, cloth, pottery, etc.) were situated at the site?
  -> is it because the site had a long life span or broad dating?
  
- When there are a lot of specific types pr. site
  -> when there are many of the multi purpose vessels (cat. 2, 4, 5) does this indicate settlements?
  -> When there are many of the wide open vessels (cat. 1 / cat. 8 carinated) does this indicate many feasts to display food, i.e. urban sites?
  -> when there are many storage pots (cat. 6, 9, 10, 11) does this also indicate urban hubs or huge settlements?
  -> when there are many vertical oval vessels (cat. 9, 10, 11) that need stabilization, does that mean a change in storage technology? 
      Or does it indicate that the site was more sedentary?
      Or a change in culture?
      Or change in climate to hotter?

------------------------------------------
# STEP 8: Plot of rim type counts per site
------------------------------------------

This step explores which rim type is dominant per site. 

It follows the same method as the previous step regarding vessel types.

# STEP 0: View rim types in the spreadsheet

This step is just to see if there are typos or other

```{r, echo=TRUE}
# View unique rim types
unique_rim_types <- unique(ceramics_subset$rim_category)
print(unique_rim_types)
```
Looks fine!

# STEP 01: Plot each site individually with rim type counts

OBS: "RS01" which is the addition to the data tables I produce refers to "Rim - Site" and data table 01 (ex: data_count_RS01)

```{r, echo=TRUE}
# Load required libraries
# library(ggplot2)
# library(dplyr)
# library(viridis)

# Count the occurrences of rim_category per site, excluding NA values
data_count_RS01 <- ceramics_subset %>%
  filter(!is.na(rim_category)) %>%  # Exclude rows with NA in rim_category
  group_by(site_name, rim_category) %>%
  summarise(count = n(), .groups = 'drop')

# Create a mapping of rim_category to descriptions (optional for additional info)
rim_description_map <- data.frame(
  rim_category = c("Sr", "Sp", "Sf", "Sb", "Es", "Ec", "Ecc", "Ef", "Efl", "Ep", 
                   "Et", "Esg", "Emg", "Vs", "Vc", "Oth", "Otc", "Otf", "Ith", 
                   "Itc", "Itf", "Th", "Tc", "Tf", "Ca", "B", "Y"),
  rim_description = c("Simple, rounded", "Simple, pointy", "Simple, flattened", 
                      "Simple, bevelled", "Everted, simple", "Everted, collared", 
                      "Everted, collared channelled", "Everted, flaring", 
                      "Everted, flattened", "Everted, protruding", 
                      "Everted, thickened", "Everted, single groove", 
                      "Everted, multiple groove", "Vertical, simple", "Vertical, collared", 
                      "Outward thickened, hinged", "Outward thickened, curved", 
                      "Outward thickened, flattened", "Inward thickened, hinged",
                      "Inward thickened, curved", "Inward thickened, flattened",
                      "Thickened, hinged", "Thickened, curved", "Thickened, flattened",
                      "Carinated", "Backward rims", "Y-rims")
)

# Ensure `rim_category` columns are character for merging
data_count_RS01$rim_category <- as.character(data_count_RS01$rim_category)
rim_description_map$rim_category <- as.character(rim_description_map$rim_category)

# Merge the descriptions with the dataset
data_count_RS01 <- data_count_RS01 %>%
  left_join(rim_description_map, by = "rim_category")

# Ensure the x-axis and legend are dynamically ordered based on present rim types
data_count_RS01 <- data_count_RS01 %>%
  mutate(
    rim_category = factor(rim_category, levels = unique(data_count_RS01$rim_category)),
    rim_description = factor(rim_description, levels = unique(data_count_RS01$rim_description))
  )

# Create a function to generate a plot for a single site
plot_site_RS01 <- function(site_name) {
  site_data <- data_count_RS01 %>% filter(site_name == !!site_name)
  
  ggplot(site_data, aes(x = rim_category, y = count, fill = rim_description)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_viridis(discrete = TRUE, option = "D") +
    theme_minimal() +
    labs(
      title = paste("Rim Types at Site:", site_name),
      x = "Rim Category",
      y = "Count",
      fill = "Rim Type"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Get unique site names
site_names_RS01 <- unique(data_count_RS01$site_name)

# Generate and print plots for each site
for (site in site_names_RS01) {
  print(plot_site_RS01(site))
}

```

So, this is perfect! I need to interpret it later. 

OBS: You need to determine a specific colour to each rim type. Right now it changes in the plots. 

# STEP 02: Plot all the sites in three diagrams with the different rim types represented

OBS: "RS02" which is the addition to the data tables I produce refers to "Rim - Site" and datatable 02 (ex: data_count_RS02)

#Prepare data for three plots

```{r, echo=TRUE}
# Remove rows where rim_category is NA
data_count_RS02 <- ceramics_subset %>%
  filter(!is.na(rim_category)) %>%  # Drop NA values in rim_category
  group_by(site_name, rim_category) %>%
  summarise(count = n(), .groups = 'drop')

# Create a mapping of rim_category to rim descriptions (using abbreviations)
rim_descriptions_RS02 <- data.frame(
  rim_category = c("Sr", "Sp", "Sf", "Sb", "Es", "Ec", "Ecc", "Ef", "Efl", "Ep", 
                   "Et", "Esg", "Emg", "Vs", "Vc", "Oth", "Otc", "Otf", "Ith", 
                   "Itc", "Itf", "Th", "Tc", "Tf", "Ca", "B", "Y"),
  rim_description = c("Simple, rounded", "Simple, pointy", "Simple, flattened", 
                      "Simple, bevelled", "Everted, simple", "Everted, collared", 
                      "Everted, collared channelled", "Everted, flaring", 
                      "Everted, flattened", "Everted, protruding", 
                      "Everted, thickened", "Everted, single groove", 
                      "Everted, multiple groove", "Vertical, simple", "Vertical, collared", 
                      "Outward thickened, hinged", "Outward thickened, curved", 
                      "Outward thickened, flattened", "Inward thickened, hinged",
                      "Inward thickened, curved", "Inward thickened, flattened",
                      "Thickened, hinged", "Thickened, curved", "Thickened, flattened",
                      "Carinated", "Backward rims", "Y-rims")
)

# Ensure both dataframes use character type for `rim_category`
data_count_RS02$rim_category <- as.character(data_count_RS02$rim_category)
rim_descriptions_RS02$rim_category <- as.character(rim_descriptions_RS02$rim_category)

# Merge descriptions into the data
data_count_RS02 <- data_count_RS02 %>%
  left_join(rim_descriptions_RS02, by = "rim_category")

# Ensure `rim_category` follows its abbreviation order (not numeric)
data_count_RS02 <- data_count_RS02 %>%
  mutate(rim_category = factor(rim_category, levels = rim_descriptions_RS02$rim_category),
         rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description))

# Pivot the data to wide format: Each rim_category becomes a separate column
data_wide_RS02 <- data_count_RS02 %>%
  select(-rim_description) %>% # Exclude rim_description for the wide format
  pivot_wider(names_from = rim_category, values_from = count, values_fill = list(count = 0))

# Reshape the data back to long format for plotting
data_long_RS02 <- data_wide_RS02 %>%
  pivot_longer(cols = -site_name, names_to = "rim_category", values_to = "count") %>%
  mutate(rim_category = factor(rim_category, levels = rim_descriptions_RS02$rim_category)) # Restore factor order

# Merge back the rim abbreviations for plotting instead of descriptions
data_long_RS02 <- data_long_RS02 %>%
  left_join(rim_descriptions_RS02, by = "rim_category") %>%
  mutate(rim_category = factor(rim_category, levels = rim_descriptions_RS02$rim_category)) # Use abbreviations for the legend

```

#Make data tables for three plots

```{r, echo=TRUE}

# Split the data into three groups based on site_name
third_size_RS02 <- floor(n_distinct(data_long_RS02$site_name) / 3)
site_names_first_third_RS02 <- unique(data_long_RS02$site_name)[1:third_size_RS02]
site_names_second_third_RS02 <- unique(data_long_RS02$site_name)[(third_size_RS02 + 1):(2 * third_size_RS02)]
site_names_third_third_RS02 <- unique(data_long_RS02$site_name)[(2 * third_size_RS02 + 1):length(unique(data_long_RS02$site_name))]

# Subset the data for each third of site names
data_first_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_first_third_RS02)

data_second_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_second_third_RS02)

data_third_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_third_third_RS02)

# Ensure numeric order for rim_category and include descriptions
data_first_third_RS02 <- data_first_third_RS02 %>%
  mutate(
    rim_category = factor(rim_category, levels = as.character(1:27)),
    rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description)
  )

data_second_third_RS02 <- data_second_third_RS02 %>%
  mutate(
    rim_category = factor(rim_category, levels = as.character(1:27)),
    rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description)
  )

data_third_third_RS02 <- data_third_third_RS02 %>%
  mutate(
    rim_category = factor(rim_category, levels = as.character(1:27)),
    rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description)
  )

```

#Plot the three plots

```{r, echo=TRUE}
# Plot 1: First third of the sites
plot1_RS02 <- ggplot(data_first_third_RS02, aes(x = site_name, y = count, fill = rim_description)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (1/3)",
    fill = "Rim Description"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#Print the plot
plot1_RS02

```

You need to make the legend smaller! Use the abrivations 

```{r, echo=TRUE}
# Plot 2: Second third of the sites
plot2_RS02 <- ggplot(data_second_third_RS02, aes(x = site_name, y = count, fill = rim_description)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (2/3)",
    fill = "Rim Description"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#Print the plot
plot2_RS02
```


```{r, echo=TRUE}
# Plot 3: Third third of the sites
plot3_RS02 <- ggplot(data_third_third_RS02, aes(x = site_name, y = count, fill = rim_description)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (3/3)",
    fill = "Rim Description"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#Print the plot
plot3_RS02
```
Ok, these plots need adjustments, but I now have a full plot of the rims pr site. I have some NAs from Karkarichinkat that I need to check out. Second, I need to decide if I really need the legend here, or if I can change it to the abbreviations

```{r, echo=TRUE}
library(dplyr)
library(stringr)
library(tidyr)
library(ggplot2)
library(viridis)

# Clean up rim_category in ceramics_subset: remove extra spaces and convert to upper case
ceramics_subset <- ceramics_subset %>%
  mutate(rim_category = toupper(trimws(rim_category)))

# Remove rows where rim_category is NA and count occurrences per site
data_count_RS02 <- ceramics_subset %>%
  filter(!is.na(rim_category)) %>%  
  group_by(site_name, rim_category) %>%
  summarise(count = n(), .groups = "drop")

# Create a mapping of rim_category to rim descriptions (using abbreviations) and clean the keys
rim_descriptions_RS02 <- data.frame(
  rim_category = toupper(c("Sr", "Sp", "Sf", "Sb", "Es", "Ec", "Ecc", "Ef", "Efl", "Ep", 
                           "Et", "Esg", "Emg", "Vs", "Vc", "Oth", "Otc", "Otf", "Ith", 
                           "Itc", "Itf", "Th", "Tc", "Tf", "Ca", "B", "Y")),
  rim_description = c("Simple, rounded", "Simple, pointy", "Simple, flattened", 
                      "Simple, bevelled", "Everted, simple", "Everted, collared", 
                      "Everted, collared channelled", "Everted, flaring", 
                      "Everted, flattened", "Everted, protruding", 
                      "Everted, thickened", "Everted, single groove", 
                      "Everted, multiple groove", "Vertical, simple", "Vertical, collared", 
                      "Outward thickened, hinged", "Outward thickened, curved", 
                      "Outward thickened, flattened", "Inward thickened, hinged",
                      "Inward thickened, curved", "Inward thickened, flattened",
                      "Thickened, hinged", "Thickened, curved", "Thickened, flattened",
                      "Carinated", "Backward rims", "Y-rims"),
  stringsAsFactors = FALSE
)

# Ensure both data frames have rim_category as character
data_count_RS02 <- data_count_RS02 %>% mutate(rim_category = as.character(rim_category))
rim_descriptions_RS02$rim_category <- as.character(rim_descriptions_RS02$rim_category)

# Merge descriptions into the data using rim_category as the key
data_count_RS02 <- data_count_RS02 %>%
  left_join(rim_descriptions_RS02, by = "rim_category")

# Check the first few rows to ensure the join worked
print(head(data_count_RS02))

# Set factor levels based on the mapping order (using the abbreviations)
data_count_RS02 <- data_count_RS02 %>%
  mutate(
    rim_category = factor(rim_category, levels = rim_descriptions_RS02$rim_category),
    rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description)
  )

# (Optional) Pivot to wide and back if needed for other analyses...
# For plotting, we can use data_count_RS02 directly, or if you have a split dataset,
# make sure it comes from this cleaned version.

```

# prepare three plots

```{r, echo=TRUE}
# Split the data into three groups based on site_name
# (We assume site_name ordering is the desired split)
total_sites <- length(unique(data_long_RS02$site_name))
third_size_RS02 <- floor(total_sites / 3)
site_names_first_third_RS02 <- unique(data_long_RS02$site_name)[1:third_size_RS02]
site_names_second_third_RS02 <- unique(data_long_RS02$site_name)[(third_size_RS02 + 1):(2 * third_size_RS02)]
site_names_third_third_RS02 <- unique(data_long_RS02$site_name)[(2 * third_size_RS02 + 1):total_sites]

# Subset the data for each group
data_first_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_first_third_RS02)

data_second_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_second_third_RS02)

data_third_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_third_third_RS02)

```

#Create the three plots

```{r, echo=TRUE}
# Create Plot 1: First third of the sites
plot1a_RS02 <- ggplot(data_first_third_RS02, aes(x = site_name, y = count, fill = rim_category)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (1/3)",
    fill = "Rim Type"  # Legend will display abbreviations
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Create Plot 2: Second third of the sites
plot2a_RS02 <- ggplot(data_second_third_RS02, aes(x = site_name, y = count, fill = rim_category)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (2/3)",
    fill = "Rim Type"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Create Plot 3: Third third of the sites
plot3a_RS02 <- ggplot(data_third_third_RS02, aes(x = site_name, y = count, fill = rim_category)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (3/3)",
    fill = "Rim Type"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#Print plot 1

```{r, echo=TRUE}
plot1a_RS02
```

#Print plot 2

```{r, echo=TRUE}
plot2a_RS02
```

#Print plot 3

```{r, echo=TRUE}
plot3a_RS02
```
Ok, now I got the three plots with a proper legend. I am not sure if I can use it because there is too much data in one plot, and you cannot really differentiate the colors.. Perhaps I need more clear colours or something, but that is for later..

Or perhaps only have 3-4 site per plot!

-------------------------------------
# STEP 9: Plot of base types per site
-------------------------------------

In the following I will explore which base types are dominant per site.

I use the abbrivation BS01 for Base - Site and the number is the database I create

```{r, echo=TRUE}

# Load required libraries
# library(ggplot2)
# library(dplyr)
# library(viridis)

# Count the occurrences of rim_category per site, excluding NA values
data_count_BS01 <- ceramics_subset %>%
  filter(!is.na(base_category)) %>%  # Exclude rows with NA in rim_category
  group_by(site_name, base_category) %>%
  summarise(count = n(), .groups = 'drop')

# Create a mapping of base_category to descriptions (optional for additional info)
base_description_map <- data.frame(
  base_category = c("Bf", "Br", "Bpe", "Bl", "Bc", "Bpo", "Sp", "Bro", "Bt"),
  base_description = c("Bases, flat", "Bases, ring", "Bases, pedestal", 
                      "Bases, legged", "Bases, concave", "Bases, pointy", "Special", 
                      "Bases, rounded", "Bases, tripod")
)

# Ensure `base_category` columns are character for merging
data_count_BS01$base_category <- as.character(data_count_BS01$base_category)
base_description_map$base_category <- as.character(base_description_map$base_category)

# Merge the descriptions with the dataset
data_count_BS01 <- data_count_BS01 %>%
  left_join(base_description_map, by = "base_category")

# Ensure the x-axis and legend are dynamically ordered based on present base types
data_count_BS01 <- data_count_BS01 %>%
  mutate(
    base_category = factor(base_category, levels = unique(data_count_BS01$base_category)),
    base_description = factor(base_description, levels = unique(data_count_BS01$base_description))
  )

# Create a function to generate a plot for a single site
plot_site_BS01 <- function(site_name) {
  site_data <- data_count_BS01 %>% filter(site_name == !!site_name)
  
  ggplot(site_data, aes(x = base_category, y = count, fill = base_description)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_viridis(discrete = TRUE, option = "D") +
    theme_minimal() +
    labs(
      title = paste("Base Types at Site:", site_name),
      x = "Base Category",
      y = "Count",
      fill = "Base Type"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Get unique site names
site_names_BS01 <- unique(data_count_BS01$site_name)

# Generate and print plots for each site
for (site in site_names_BS01) {
  print(plot_site_BS01(site))
}
```
Damn I'm good!

OBS: I will not try to put all the data into three diagrams before I know I will use it!

OBS: You must make the columns in the same width

---------------------------------------
# STEP 10: Plot of vessel size per site
---------------------------------------

In the following I will explore which size cateogries are dominant per site

OBS I will use the SS abbreviations for Size - Site and then followed by a data number -> ex-SS01

```{r, echo=TRUE}

# Load required libraries
# library(ggplot2)
# library(dplyr)
# library(viridis)

# Count the occurrences of size_category per site, excluding NA values
data_count_SS01 <- ceramics_subset %>%
  filter(!is.na(size_category)) %>%  # Exclude rows with NA in size_category
  group_by(site_name, size_category) %>%
  summarise(count = n(), .groups = 'drop')

# Create a mapping of base_category to descriptions (optional for additional info)
size_description_map <- data.frame(
  size_category = c("a", "b", "c", "d", "e"),
  size_description = c("<14.9 cm", "15-24.9 cm", "25-34.9 cm", "35-44.9 cm", ">45 cm")
)

# Ensure `size_category` columns are character for merging
data_count_SS01$size_category <- as.character(data_count_SS01$size_category)
size_description_map$size_category <- as.character(size_description_map$size_category)

# Merge the descriptions with the dataset
data_count_SS01 <- data_count_SS01 %>%
  left_join(size_description_map, by = "size_category")

# Ensure the x-axis and legend are dynamically ordered based on present base types
data_count_SS01 <- data_count_SS01 %>%
  mutate(
    size_category = factor(size_category, levels = unique(data_count_SS01$size_category)),
    size_description = factor(size_description, levels = unique(data_count_SS01$size_description))
  )

# Create a function to generate a plot for a single site
plot_site_SS01 <- function(site_name) {
  site_data <- data_count_SS01 %>% filter(site_name == !!site_name)
  
  ggplot(site_data, aes(x = size_category, y = count, fill = size_description)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_viridis(discrete = TRUE, option = "D") +
    theme_minimal() +
    labs(
      title = paste("Size Categories at Site:", site_name),
      x = "Size Category",
      y = "Count",
      fill = "Size Type"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Get unique site names
site_names_SS01 <- unique(data_count_SS01$site_name)

# Generate and print plots for each site
for (site in site_names_SS01) {
  print(plot_site_SS01(site))
}
```
Damn I'm good!

OBS: I just noticed that the colors are not consistent, so the last category is always yellow for an example. I need to change this so the colors and types are consistent. This applies to all my previous plots!

---------------------------
# Mean, median, range, SD #
---------------------------

Calculating the mean + median + range + Standard Deviation (SD) for:

- actual diameter (orifice)
- actual height
- actual width

Mean: the mean, or average, is calculated by summing all the values in a dataset and then dividing that total by the number of values. It represents a central value of a dataset and is the most common measure of central tendency

Median: A median is the middle value in a dataset that has been arranged in order from smallest to largest. It divides the dataset in half, with 50% of the values being equal to or smaller than the median and 50% being equal to or larger than the median. To find the median, first sort the data, then identify the middle number for an odd number of data points, or calculate the average of the two middle numbers for an even number of data points. 

Range: In mathematics, the term "range" has two primary meanings: in statistics, it is the difference between the highest and lowest values in a dataset - To find the statistical range, you identify the largest and smallest numbers in a set and subtract the smallest from the largest.

SD: A standard deviation is a statistical measure of the amount of variation or dispersion within a set of data values, indicating how much individual data points typically deviate from the mean (average) of the set. A low standard deviation signifies that the data points tend to be close to the mean, while a high standard deviation indicates that the data points are spread out over a wider range of values.  

OBS: The difference between the mean and the median is that the mean is the most frequent number, and the median is where the middle of the dataset is based on the total count of data points.

#descriptive statistics for all the vessel types

```{r, echo=TRUE}

# Descriptive statistics for key numeric variables
numeric_vars <- c("actual_width", "actual_diameter", "actual_height")

descriptive_stats <- ceramics_data %>%
  select(all_of(numeric_vars)) %>%
  summarise(
    across(everything(),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  )

descriptive_stats

```

Interpretation: 

Lets do it for each type category!

-------------------------------------------
# Descritive statistics per type_category #
-------------------------------------------

This chunk will calculate the mean, median, min/max, SD, for each vessel type category

First make a new variable for the descriptive statistics and load needed libraries

```{r, echo=TRUE}
library(dplyr)
library(tidyr)

numeric_vars <- c("actual_width", "actual_diameter", "actual_height")
```

#Type 1 "Wide-open sphere"

```{r, echo=TRUE}

descriptive_stats_type1 <- ceramics_data %>%
  filter(type_category == "1") %>%
  select(all_of(numeric_vars)) %>%
  drop_na() %>% # Remove rows with any NAs
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type1 <- descriptive_stats_type1 %>% mutate(Value = round(Value, 2))

descriptive_stats_type1

```

Interpretation:

# Type 2 "Open sphere"

```{r, echo=TRUE}

descriptive_stats_type2 <- ceramics_data %>%
  filter(type_category == "2") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type2
```

Interpretation:

# Type 3 (Closed hor. ellipsoid)

```{r, echo=TRUE}

descriptive_stats_type3 <- ceramics_data %>%
  filter(type_category == "3") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type3
```

Interpretation:

# Type 4 (Vertical sphere)

```{r, echo=TRUE}

descriptive_stats_type4 <- ceramics_data %>%
  filter(type_category == "4") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type4
```

Interpretation:

#Type 5 (Closed sphere)

```{r, echo=TRUE}

descriptive_stats_type5 <- ceramics_data %>%
  filter(type_category == "5") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type5
```

# Type 6 (Tightly-closed sphere)

```{r, echo=TRUE}

descriptive_stats_type6 <- ceramics_data %>%
  filter(type_category == "6") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type6
```

Interpretation:

# Type 7 (Open carinated)

```{r, echo=TRUE}

descriptive_stats_type7 <- ceramics_data %>%
  filter(type_category == "7") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type7
```

Interpretation:

# Type 8 (Wide-open carinated)

```{r, echo=TRUE}

descriptive_stats_type8 <- ceramics_data %>%
  filter(type_category == "8") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type8
```

Interpretation:

# Type 9 (Vertical ver. ellipsoid)

```{r, echo=TRUE}

descriptive_stats_type9 <- ceramics_data %>%
  filter(type_category == "9") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type9
```

Interpretation:

# Type 10 (Closed ver. ellipsoid)

```{r, echo=TRUE}

descriptive_stats_type10 <- ceramics_data %>%
  filter(type_category == "10") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type10
```

Interpretation:

# Type 11 (Tightly-closed ver. ellipsoid)

```{r, echo=TRUE}

descriptive_stats_type11 <- ceramics_data %>%
  filter(type_category == "11") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type11
```

Interpretation:

#Type 13 (Flasks)

I collapsed flasks and bottles

```{r, echo=TRUE}

descriptive_stats_type13 <- ceramics_data %>%
  filter(type_category == "13") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type13
```

Interpretation: It looks like this because there are only very few registrations

# Type 14 (Tellem tripods)

```{r, echo=TRUE}

descriptive_stats_type14 <- ceramics_data %>%
  filter(type_category == "14") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type14
```

Interpretation:

# Type 15 (Tellem tripods (top))

```{r, echo=TRUE}

descriptive_stats_type15 <- ceramics_data %>%
  filter(type_category == "15") %>%
  summarise(
    across(all_of(numeric_vars),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", "Statistic"),
    values_to = "Value",
    names_sep = "_(?=[^_]+$)"  # Split at last underscore: Variable first, Statistic second
  )

# Optional: round values for clarity
# descriptive_stats_type2 <- descriptive_stats_type2 %>% mutate(Value = round(Value, 2))

descriptive_stats_type15
```

Interpretation: 

# plot the values in one

Let's try to plot the mean for all the vessel types in one plot

Collapse all into one dataset and load libraries:

```{r, echo=TRUE}
library(ggplot2)
library(dplyr)

# Combine all type_category stats into one dataset
descriptive_stats_all <- bind_rows(
  descriptive_stats_type1 %>% mutate(vessel_type = 1),
  descriptive_stats_type2 %>% mutate(vessel_type = 2),
  descriptive_stats_type3 %>% mutate(vessel_type = 3),
  descriptive_stats_type4 %>% mutate(vessel_type = 4),
  descriptive_stats_type5 %>% mutate(vessel_type = 5),
  descriptive_stats_type6 %>% mutate(vessel_type = 6),
  descriptive_stats_type7 %>% mutate(vessel_type = 7),
  descriptive_stats_type8 %>% mutate(vessel_type = 8),
  descriptive_stats_type9 %>% mutate(vessel_type = 9),
  descriptive_stats_type10 %>% mutate(vessel_type = 10),
  descriptive_stats_type11 %>% mutate(vessel_type = 11),
  descriptive_stats_type13 %>% mutate(vessel_type = 13),
  descriptive_stats_type14 %>% mutate(vessel_type = 14),
  descriptive_stats_type15 %>% mutate(vessel_type = 15)
)

```

# Mean for all actual_width

```{r, echo=TRUE}
# Filter to only mean values of actual_width
mean_values_width <- descriptive_stats_all %>%
  filter(Statistic == "mean", Variable == "actual_width")

# Plot
ggplot(mean_values_width, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Mean Width per Vessel Type",
    x = "Vessel Type",
    y = "Mean Actual Width (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# Median for all actual_width

```{r, echo=TRUE}

# Filter to only median values of actual_width
median_values_width <- descriptive_stats_all %>%
  filter(Statistic == "median", Variable == "actual_width")

# Plot
ggplot(median_values_width, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Median Width per Vessel Type",
    x = "Vessel Type",
    y = "Median Actual Width (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# Min. for all actual_width

```{r, echo=TRUE}

# Filter to only min. values of actual_width
min_values_width <- descriptive_stats_all %>%
  filter(Statistic == "min", Variable == "actual_width")

# Plot
ggplot(min_values_width, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Min. Width per Vessel Type",
    x = "Vessel Type",
    y = "Min. Actual Width (cm)"
  ) +
  theme_minimal()

```

Interpretaion:

# Max. for all actual width

```{r, echo=TRUE}

# Filter to only max. values of actual_width
max_values_width <- descriptive_stats_all %>%
  filter(Statistic == "max", Variable == "actual_width")

# Plot
ggplot(max_values_width, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Max. Width per Vessel Type",
    x = "Vessel Type",
    y = "Max. Actual Width (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# SD for all actual width

```{r, echo=TRUE}

# Filter to only SD values of actual_width
SD_values_width <- descriptive_stats_all %>%
  filter(Statistic == "sd", Variable == "actual_width")

# Plot
ggplot(SD_values_width, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "SD Width per Vessel Type",
    x = "Vessel Type",
    y = "SD Actual Width (cm)"
  ) +
  theme_minimal()

```

Interpretation:

The ones with lowest SD are 14 and 15 which are also the two groups I see as most specialized of the vessel types! Good result! The less SD the more standardized the categories are!

It is funny that type 11 (tightly closed vertical oval) has the most deviation! Perhaps it is because of the small sample size??

# Mean for all actual_height

```{r, echo=TRUE}
# Filter to only mean values of actual_height
mean_values_height <- descriptive_stats_all %>%
  filter(Statistic == "mean", Variable == "actual_height")

# Plot
ggplot(mean_values_height, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Mean Height per Vessel Type",
    x = "Vessel Type",
    y = "Mean Actual Height (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# Median for all actual_height

```{r, echo=TRUE}
# Filter to only median values of actual_height
median_values_height <- descriptive_stats_all %>%
  filter(Statistic == "median", Variable == "actual_height")

# Plot
ggplot(median_values_height, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Median Height per Vessel Type",
    x = "Vessel Type",
    y = "Median Actual Height (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# Min. for all actual_height

```{r, echo=TRUE}
# Filter to only min. values of actual_height
min_values_height <- descriptive_stats_all %>%
  filter(Statistic == "min", Variable == "actual_height")

# Plot
ggplot(min_values_height, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Min. Height per Vessel Type",
    x = "Vessel Type",
    y = "Min. Actual Height (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# Max. for all actual_height

```{r, echo=TRUE}
# Filter to only max. values of actual_height
max_values_height <- descriptive_stats_all %>%
  filter(Statistic == "max", Variable == "actual_height")

# Plot
ggplot(max_values_height, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Max. Height per Vessel Type",
    x = "Vessel Type",
    y = "Max. Actual Height (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# SD for all actual_height

```{r, echo=TRUE}
# Filter to only SD values of actual_height
SD_values_height <- descriptive_stats_all %>%
  filter(Statistic == "sd", Variable == "actual_height")

# Plot
ggplot(SD_values_height, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "SD Height per Vessel Type",
    x = "Vessel Type",
    y = "SD Actual Height (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# Mean for all actual_diameter

```{r, echo=TRUE}
# Filter to only mean values of actual_diameter
mean_values_diameter <- descriptive_stats_all %>%
  filter(Statistic == "mean", Variable == "actual_diameter")

# Plot
ggplot(mean_values_diameter, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Mean Diameter per Vessel Type",
    x = "Vessel Type",
    y = "Mean Actual Diameter (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# Median for all actual_diameter

```{r, echo=TRUE}
# Filter to only median values of actual_diameter
median_values_diameter <- descriptive_stats_all %>%
  filter(Statistic == "median", Variable == "actual_diameter")

# Plot
ggplot(median_values_diameter, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Median Diameter per Vessel Type",
    x = "Vessel Type",
    y = "Median Actual Diameter (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# Min. for all actual_diameter

```{r, echo=TRUE}
# Filter to only min. values of actual_diameter
min_values_diameter <- descriptive_stats_all %>%
  filter(Statistic == "min", Variable == "actual_diameter")

# Plot
ggplot(min_values_diameter, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Min. Diameter per Vessel Type",
    x = "Vessel Type",
    y = "Min. Actual Diameter (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# Max. for all actual_diameter

```{r, echo=TRUE}
# Filter to only max. values of actual_diameter
max_values_diameter <- descriptive_stats_all %>%
  filter(Statistic == "max", Variable == "actual_diameter")

# Plot
ggplot(max_values_diameter, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "Max. Diameter per Vessel Type",
    x = "Vessel Type",
    y = "Max. Actual Diameter (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# SD for all actual_diameter

```{r, echo=TRUE}
# Filter to only SD values of actual_diameter
SD_values_diameter <- descriptive_stats_all %>%
  filter(Statistic == "sd", Variable == "actual_diameter")

# Plot
ggplot(SD_values_diameter, aes(x = factor(vessel_type), y = Value)) +
  geom_col(fill = "lightblue") +
  labs(
    title = "SD Diameter per Vessel Type",
    x = "Vessel Type",
    y = "SD Actual Diameter (cm)"
  ) +
  theme_minimal()

```

Interpretation:

# coefficient of variation per type category

```{r, echo=TRUE}
library(dplyr)

# Calculate coefficient of variation (CV = sd / mean)
cv_by_type <- ceramics_data %>%
  filter(!is.na(type_category)) %>%  # ensure type_category exists
  group_by(type_category) %>%
  summarise(across(
    all_of(numeric_vars),
    ~ (sd(.x, na.rm = TRUE) / mean(.x, na.rm = TRUE)) * 100,  # *100 for percentage
    .names = "CV_{.col}"
  )) %>%
  arrange(type_category)

# View result
cv_by_type
```

# plot in bar plot

```{r, echo=TRUE}
library(dplyr)
library(tidyr)
library(ggplot2)

# Calculate coefficient of variation (CV = sd / mean * 100)
cv_by_type <- ceramics_data %>%
  filter(!is.na(type_category)) %>%
  group_by(type_category) %>%
  summarise(across(
    all_of(numeric_vars),
    ~ (sd(.x, na.rm = TRUE) / mean(.x, na.rm = TRUE)) * 100,  # CV in percentage
    .names = "CV_{.col}"
  )) %>%
  arrange(type_category)

# Reshape data for plotting
cv_long <- cv_by_type %>%
  pivot_longer(
    cols = starts_with("CV_"),
    names_to = "Variable",
    values_to = "CV"
  ) %>%
  mutate(
    Variable = recode(Variable,
                      "CV_actual_width" = "Width",
                      "CV_actual_diameter" = "Diameter",
                      "CV_actual_height" = "Height")
  )

# Plot grouped bar chart with threshold line (no text)
ggplot(cv_long, aes(x = factor(type_category), y = CV, fill = Variable)) +
  geom_col(position = position_dodge(width = 0.8)) +
  geom_hline(yintercept = 40, linetype = "dashed", color = "red", size = 1) +
  labs(
    title = "Coefficient of Variation (CV) by Vessel Type",
    subtitle = "Red dashed line marks high variability threshold (40%)",
    x = "Vessel Type",
    y = "CV (%)",
    fill = "Measurement"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )

```

Interpretation:

Bars above the red dashed line (40%) indicate types with notably high variation  possibly less standardized or functionally diverse.

Bars well below the line suggest more controlled, standardized production.

#Density plots of vessel size groups

#Code by Nick

```{r}
ggplot(ceramics_data,aes(actual_width))+
  geom_histogram(binwidth = 2
          )

```

NICK: In this step nick told me to try to find the size groups and confirm my own size groups a-e. When I change the binwidth in the code it changes the cm that is the threshold. So, if the binwidth is 10 (as my size groups) no real patterns emerge, but is I use 2 cm then some new groups appear.

NICK: I just do these analysis for confirming my 10cm size groups based on width!

-> in general I need to explore statistically which size groups there can be in the material. 

OBS: Try to do density curves per pot type!

#actual_width (binwidth 2)

```{r, echo=TRUE}
ggplot(
  ceramics_data %>% filter(!is.na(actual_width) & actual_width != 0),
  aes(x = actual_width)
) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 2,
                 fill = "lightblue", color = "black") +
  geom_density(color = "red", size = 1.2) +
  scale_x_continuous(breaks = seq(0, 60, by = 10)) +
  labs(
    title = "Distribution and Density of Total Width (2 cm)",
    x = "Actual Width (cm)",
    y = "Density"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

(- I think I see there is four to five size groups: 10-15 cm / 15-20 cm / 25-30 cm / 35-40 cm / (55-60 cm))
- After the red line was added I see two size groups: 10-15 cm / 25-30 cm
- Most vessels are between 10-15 cm in width
- There is a high variability in the material, with some smaller and many more wide vessels
- there is a long tail towards higher widths, suggesting that there are many very wide vessels

#actual_width (binwidth 10)

```{r, echo=TRUE}
ggplot(
  ceramics_data %>% filter(!is.na(actual_width) & actual_width != 0),
  aes(x = actual_width)
) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 10,
                 fill = "lightblue", color = "black") +
  geom_density(color = "red", size = 1.2) +
  scale_x_continuous(breaks = seq(0, 60, by = 10)) +
  labs(
    title = "Distribution and Density of Total Width (10 cm)",
    x = "Actual Width (cm)",
    y = "Density"
  ) +
  theme_minimal(base_size = 13)

```

#actual_height

```{r, echo=TRUE}
ggplot(
  ceramics_data %>% filter(!is.na(actual_height) & actual_height != 0),
  aes(x = actual_height)
) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 2,
                 fill = "lightblue", color = "black") +
  geom_density(color = "red", size = 1.2) +
  scale_x_continuous(breaks = seq(0, 60, by = 10)) +
  labs(
    title = "Distribution and Density of Actual Height",
    x = "Actual Height (cm)",
    y = "Density"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

(- I think I see three size groups: 5-15 cm / 30-35 cm / 45-50 cm)
- after the red line was added I see two size groups: 5-10 cm / 30-35 cm
- Most of the vessels are 10 cm high
- There is a high variability in the material with some smaller and many taller vessels
- there is a long tail towards higher heights, suggesting that there are many very tall vessels


#actual_diameter

```{r, echo=TRUE}
ggplot(
  ceramics_data %>% filter(!is.na(actual_diameter) & actual_diameter != 0),
  aes(x = actual_diameter)
) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 2,
                 fill = "lightblue", color = "black") +
  geom_density(color = "red", size = 1.2) +
  scale_x_continuous(breaks = seq(0, 60, by = 10)) +
  labs(
    title = "Distribution and Density of Actual Diameter",
    x = "Actual Diameter (cm)",
    y = "Density"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

(- I think I see four / five size groups: 10-15 cm / 15-20 cm / (20-25 cm) / 30-35 cm / 35-40 cm)
- After the red line was added I see 2-3 size groups: 10-15 cm / 30-35 cm / (40-45 cm)
- Most vessels have an orifice between 10-15 cm
- There is a high variability in the material, with some smaller and many larger vessel orifices
- There is a long tail towards higher orifice sizes, suggesting that there are many vessels with larger orifice sizes

```{r, echo=TRUE}
library(ggplot2)
library(dplyr)

# Remove zeros and NAs first
ceramics_data_clean <- ceramics_data %>%
  mutate(
    actual_width = na_if(actual_width, 0),
    actual_height = na_if(actual_height, 0)
  ) %>%
  filter(!is.na(actual_width), !is.na(actual_height), !is.na(type_category))

# Density plot for Actual Width by Vessel Type
ggplot(ceramics_data_clean, aes(x = actual_width, fill = factor(type_category))) +
  geom_density(alpha = 0.5) +
  labs(
    title = "Density Plot of Actual Width by Vessel Type",
    x = "Actual Width (cm)",
    y = "Density",
    fill = "Vessel Type"
  ) +
  theme_minimal(base_size = 13)

```
Interpretation:

```{r, echo=TRUE}
# Density plot for Actual Height by Vessel Type
ggplot(ceramics_data_clean, aes(x = actual_height, fill = factor(type_category))) +
  geom_density(alpha = 0.5) +
  labs(
    title = "Density Plot of Actual Height by Vessel Type",
    x = "Actual Height (cm)",
    y = "Density",
    fill = "Vessel Type"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

# Density plots by vessel type for width, height, and diameter

```{r, echo=TRUE}
library(ggplot2)
library(dplyr)

# Clean dataset: convert 0 to NA and remove missing values
ceramics_data_clean <- ceramics_data %>%
  mutate(
    actual_width = na_if(actual_width, 0),
    actual_height = na_if(actual_height, 0),
    actual_diameter = na_if(actual_diameter, 0),
    litres = na_if(litres, 0)
  ) %>%
  filter(
    !is.na(type_category),
    !is.na(actual_width),
    !is.na(actual_height),
    !is.na(actual_diameter),
    !is.na(litres)
  )
```

```{r, echo=TRUE}
# --- WIDTH ---
ggplot(ceramics_data_clean, aes(x = actual_width, fill = factor(type_category))) +
  geom_density(alpha = 0.7, color = "black") +
  facet_wrap(~ type_category, scales = "free_y") +
  labs(
    title = "Density Plot of Total Width by Vessel Type",
    x = "Actual Width (cm)",
    y = "Density"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "none")
```

Interpretation: 

```{r, echo=TRUE}

# --- HEIGHT ---
ggplot(ceramics_data_clean, aes(x = actual_height, fill = factor(type_category))) +
  geom_density(alpha = 0.7, color = "black") +
  facet_wrap(~ type_category, scales = "free_y") +
  labs(
    title = "Density Plot of Total Height by Vessel Type",
    x = "Actual Height (cm)",
    y = "Density"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "none")
```



```{r, echo=TRUE}
# --- DIAMETER ---
ggplot(ceramics_data_clean, aes(x = actual_diameter, fill = factor(type_category))) +
  geom_density(alpha = 0.7, color = "black") +
  facet_wrap(~ type_category, scales = "free_y") +
  labs(
    title = "Density Plot of Orifice Diameter by Vessel Type",
    x = "Orifice Diameter (cm)",
    y = "Density"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "none")

```

Interpretation:

```{r, echo=TRUE}
# --- Clean data ---
ceramics_data_clean <- ceramics_data %>%
  mutate(litres = na_if(litres, 0)) %>%
  drop_na(litres)

# --- Get unique vessel types ---
type_list <- sort(unique(ceramics_data_clean$type_category))

# --- Loop: one plot per vessel type ---
for (t in type_list) {
  
  df_t <- ceramics_data_clean %>% filter(type_category == t)
  
  xmax <- max(df_t$litres, na.rm = TRUE)
  
  p <- ggplot(df_t, aes(x = litres)) +
    geom_density(fill = "steelblue", alpha = 0.7, color = "black") +
    scale_x_continuous(
      limits = c(0, xmax),
      expand = c(0, 0)   # no extra padding
    ) +
    labs(
      title = paste("Density Plot of Volume  Vessel Type", t),
      x = "Litres",
      y = "Density"
    ) +
    theme_minimal(base_size = 14)
  
  print(p)
}


```

# Volume per vessel type

```{r, echo=TRUE}
# --- volume ---

# --- Clean data: remove NA or zero volume ---
ceramics_vol <- ceramics_data %>%
  mutate(litres = na_if(litres, 0)) %>%
  drop_na(litres)

# --- Summarise volume per type (max volume per vessel type) ---
volume_summary <- ceramics_vol %>%
  group_by(type_category) %>%
  summarise(
    max_litres = max(litres, na.rm = TRUE),
    .groups = "drop"
  )

# --- Horizontal bar plot (ggplot chooses best x-axis automatically) ---
ggplot(volume_summary, aes(y = factor(type_category), x = max_litres)) +
  geom_col(fill = "steelblue") +
  scale_x_continuous() +   # automatic axis
  labs(
    title = "Maximum Vessel Volume (Litres) per Type",
    x = "Volume (Litres)",
    y = "Vessel Type"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold"),
    axis.text.y = element_text(size = 15)
  )


```



```{r, echo=TRUE}
library(dplyr)
library(knitr)

# --- Clean data: remove NA or zero volume ---
ceramics_vol <- ceramics_data %>%
  mutate(litres = na_if(litres, 0)) %>%
  drop_na(litres)

# --- Descriptive statistics for litres per vessel type ---
descriptive_stats <- ceramics_vol %>%
  group_by(type_category) %>%
  summarise(
    count = n(),
    mean_litres = mean(litres),
    median_litres = median(litres),
    min_litres = min(litres),
    max_litres = max(litres),
    sd_litres = sd(litres),
    .groups = "drop"
  ) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2)))
```

```{r, echo=TRUE}
# --- Nice formatted table ---
kable(
  descriptive_stats,
  caption = "Descriptive Statistics for Vessel Volume (Litres) by Vessel Type",
  align = "c"
)

```

# Range of volume per type

```{r, echo=TRUE}
library(dplyr)
library(ggplot2)

# --- Clean data: remove NA or zero volume ---
ceramics_vol <- ceramics_data %>%
  mutate(litres = na_if(litres, 0)) %>%
  drop_na(litres)

# --- Ensure vessel types are ordered 1  11 ---
ceramics_vol$type_category <- factor(
  ceramics_vol$type_category,
  levels = sort(unique(ceramics_vol$type_category))
)

# --- Create one plot per vessel type ---
plot_list <- lapply(levels(ceramics_vol$type_category), function(vt) {
  
  df_sub <- ceramics_vol %>% filter(type_category == vt)
  
  ggplot(df_sub, aes(x = litres, y = type_category)) +
    geom_boxplot(
      fill = "steelblue",
      color = "black",
      outlier.color = "red",
      outlier.size = 2
    ) +
    labs(
      title = paste("Distribution of Vessel Volume (Litres)  Type", vt),
      x = "Litres",
      y = "Vessel Type"
    ) +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(face = "bold"),
      axis.text.y = element_text(size = 12)
    )
})

# Name each plot in the list
names(plot_list) <- paste0("Type_", levels(ceramics_vol$type_category))
```

```{r, echo=TRUE}
# Print
plot_list$Type_1
```

```{r, echo=TRUE}
# Print
plot_list$Type_2
```

```{r, echo=TRUE}
# Print
plot_list$Type_3
```

```{r, echo=TRUE}
# Print
plot_list$Type_4
```

```{r, echo=TRUE}
# Print
plot_list$Type_5
```

```{r, echo=TRUE}
# Print
plot_list$Type_6
```

```{r, echo=TRUE}
# Print
plot_list$Type_7
```

```{r, echo=TRUE}
# Print
plot_list$Type_8
```

```{r, echo=TRUE}
# Print
plot_list$Type_9
```

```{r, echo=TRUE}
# Print
plot_list$Type_10
```

```{r, echo=TRUE}
# Print
plot_list$Type_2
```

Each vessel type displays:

Box = IQR (25%  75%)

Middle line = Median

Whiskers = Min  Max (within 1.5IQR)

Red dots = outliers (if any)

# Combined Density Plot (Width, Height, Diameter) per Vessel Type

```{r, echo=TRUE}
library(ggplot2)
library(dplyr)
library(tidyr)

# Clean dataset: replace 0 with NA, and remove incomplete rows
ceramics_data_clean <- ceramics_data %>%
  mutate(
    actual_width = na_if(actual_width, 0),
    actual_height = na_if(actual_height, 0),
    actual_diameter = na_if(actual_diameter, 0)
  ) %>%
  filter(
    !is.na(type_category),
    !is.na(actual_width),
    !is.na(actual_height),
    !is.na(actual_diameter)
  )

# Reshape data to long format for plotting all dimensions together
ceramics_long <- ceramics_data_clean %>%
  pivot_longer(
    cols = c(actual_width, actual_height, actual_diameter),
    names_to = "Measurement",
    values_to = "Value"
  )

# Clean up labels
ceramics_long$Measurement <- recode(
  ceramics_long$Measurement,
  actual_width = "Width",
  actual_height = "Height",
  actual_diameter = "Diameter"
)

# Combined density plot (with correct legend)
ggplot(ceramics_long, aes(x = Value, fill = Measurement)) +
  geom_density(alpha = 0.5, color = "black") +
  facet_wrap(~ type_category, scales = "free_y") +
  scale_fill_manual(values = c(
    "Width" = "#1f77b4",
    "Height" = "#2ca02c",
    "Diameter" = "#ff7f0e"   # corrected label here
  )) +
  labs(
    title = "Density Plot of Width, Height, and Diameter by Vessel Type",
    x = "Measurement Value (cm)",
    y = "Density",
    fill = "Measurement"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    panel.grid.minor = element_blank()
  )

```

How to interpret:

Each facet = one vessel type.
Each color = a different dimension (Width, Height, Diameter).
If one curve is narrower or shifted, it means that dimension is more consistent or larger/smaller than the others.
Overlapping curves show similar size ranges; separated curves show different scaling patterns.

Quick interpretation guide:

- Each panel shows the size variation of one vessel type.
- A narrow peak = consistent shape/size.
- A broad peak or multiple humps = greater variation or sub-groups within that type.
Comparing across width, height, and diameter helps identify which dimension varies most within a type.

Detailed interpretation guide:

To interpret a density plot, look at the x-axis for the range of values, the y-axis for the relative likelihood of those values, and the curve's shape to understand the distribution's central tendency (peak), variability (width), and outliers (tails). 

Height of the curve: A taller peak indicates a higher concentration of data points, meaning that the values on the x-axis at that point are more frequent or likely. 

Peak(s): The highest point(s) of the curve represent the mode(s) of the distribution, which are the most common values.

A "bell curve" with two peaks: also called a bimodal distribution, indicates that your data represents two different populations or groups rather than a single, continuous one. To interpret it, you should acknowledge it as two separate distributions, identify the location of each peak, and use the mean and standard deviation with caution, as they will likely be misleading averages that fall between the two groups

Width: The width of the curve indicates variability or spread in the data. A wider curve suggests greater spread, while a narrower curve suggests less spread. 

Shape: The overall shape provides insight into the distribution.
  Symmetry: A symmetric curve (like the classic bell curve) suggests the data is evenly distributed around the mean.
  Skewness: A curve that is stretched to one side (e.g., a long right tail) indicates a skewed distribution, meaning there are   more extreme values on that side. 

Tails: The tails of the curve show the probability of observing extreme values. Long tails suggest a higher probability of outliers. 

Area under the curve: The total area under the curve is always equal to 1, representing 100% of the data. The area under a specific section of the curve can be used to estimate the percentage of data that falls within that range. 


#Cluster Analysis: Vessel Types by 'width' and 'height' Categories

NICK: before doing cluster analysis, define from the groups above which vessel types are worth clustering together (the ones that have more than one peak). Then do a cluster analysis per type group. 

NOTE: Perhaps identify which sites the vessels represent!

Define optimal amount of clusters for the three parameters

```{r, echo=TRUE}
library(dplyr)
library(cluster)   # for silhouette
library(factoextra) # for fviz_nbclust

# Prepare data
size_data <- ceramics_data %>%
  select(actual_width, actual_height, actual_diameter) %>%
  filter(!is.na(actual_width) & !is.na(actual_height) & !is.na(actual_diameter) &
         actual_width != 0 & actual_height != 0 & actual_diameter != 0)

# Standardize numeric variables
size_scaled <- scale(size_data)

# Use fviz_nbclust to find optimal k (hierarchical + silhouette)
fviz_nbclust(size_scaled, FUNcluster = hcut, method = "silhouette") +
  labs(subtitle = "Optimal number of clusters by silhouette method")
```
My optimal number of clusters are 2


```{r, echo=TRUE}
# Load required packages
library(dplyr)
library(ggplot2)
library(ggrepel)

# Step 1: Prepare data
size_data <- ceramics_data %>%
  select(type_category, actual_width, actual_height) %>%
  filter(!is.na(actual_width) & !is.na(actual_height) & actual_width != 0 & actual_height != 0)

# Step 2: Standardize numeric variables for clustering
size_scaled <- scale(size_data[, c("actual_width", "actual_height")])

# Step 3: Hierarchical clustering
dist_matrix <- dist(size_scaled)
hclust_model <- hclust(dist_matrix, method = "ward.D2")

# Step 4: Choose number of clusters (adjust as needed)
k <- 2
size_data$cluster <- cutree(hclust_model, k = k)

# Step 5: Compute cluster centroids
cluster_centroids <- size_data %>%
  group_by(cluster) %>%
  summarise(
    mean_width = mean(actual_width, na.rm = TRUE),
    mean_height = mean(actual_height, na.rm = TRUE)
  )

# Step 6: Plot clusters with colors by vessel type
ggplot(size_data, aes(x = actual_width, y = actual_height, color = factor(type_category))) +
  geom_point(size = 3, alpha = 0.8) +
  geom_point(
    data = cluster_centroids,
    aes(x = mean_width, y = mean_height),
    color = "black", size = 5, shape = 8
  ) +
  geom_text_repel(
    data = cluster_centroids,
    aes(x = mean_width, y = mean_height, label = paste("Cluster", cluster)),
    color = "black", size = 4
  ) +
  labs(
    title = "Cluster Analysis: Vessel Types by Size (Width vs Height)",
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Type Category"
  ) +
  theme_minimal(base_size = 13) +
  scale_color_manual(values = rainbow(length(unique(size_data$type_category))))

```

Hmm, it is a little hard to see all the details

Perhaps I should only do the cluster analysis for types 1-11 and exclude the flasks and Tellem tripods?

Right now I am comparing apples and bananas, above!

#Cluster Analysis: Vessel Types by 'width' and 'height' Categories with cirles around the clusters

```{r, echo=TRUE}
library(dplyr)
library(ggplot2)
library(ggrepel)

# Step 1: Prepare data
size_data <- ceramics_data %>%
  select(type_category, actual_width, actual_height) %>%
  filter(!is.na(actual_width) & !is.na(actual_height) & actual_width != 0 & actual_height != 0)

# Step 2: Standardize numeric variables for clustering
size_scaled <- scale(size_data[, c("actual_width", "actual_height")])

# Step 3: Hierarchical clustering
dist_matrix <- dist(size_scaled)
hclust_model <- hclust(dist_matrix, method = "ward.D2")

# Step 4: Choose number of clusters
k <- 2
size_data$cluster <- cutree(hclust_model, k = k)

# Step 5: Compute cluster centroids
cluster_centroids <- size_data %>%
  group_by(cluster) %>%
  summarise(
    mean_width = mean(actual_width, na.rm = TRUE),
    mean_height = mean(actual_height, na.rm = TRUE)
  )

# Step 6: Plot clusters with colors by vessel type and circles around clusters
ggplot(size_data, aes(x = actual_width, y = actual_height, color = factor(type_category))) +
  geom_point(size = 3, alpha = 0.8) +
  # Add ellipses around clusters
  stat_ellipse(aes(group = cluster), type = "norm", linetype = 2, color = "black", size = 1, alpha = 0.2) +
  geom_point(
    data = cluster_centroids,
    aes(x = mean_width, y = mean_height),
    color = "black", size = 5, shape = 8
  ) +
  geom_text_repel(
    data = cluster_centroids,
    aes(x = mean_width, y = mean_height, label = paste("Cluster", cluster)),
    color = "black", size = 4
  ) +
  labs(
    title = "Cluster Analysis: Vessel Types by Size (Width vs Height)",
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Type Category"
  ) +
  theme_minimal(base_size = 13) +
  scale_color_manual(values = rainbow(length(unique(size_data$type_category))))

```

# Cluster analysis per vessel type only including width, height and orifice

First identify the optimal amount of clusters per vessel type

What This Code Does

- Loops through each unique vessel_type.

- Runs PAM clustering (robust for your type of data).

- Calculates the average silhouette width for k = 210.

- Picks the k that gives the best cluster separation.

- Prints the optimal cluster number per vessel type.

- Skips vessel types with too few valid measurements.

```{r, echo=TRUE}

# Load required libraries
library(cluster)
library(factoextra)
library(dplyr)

# Clean the data: remove missing or zero values
ceramics_clean <- ceramics_data %>%
  filter(!is.na(actual_width), !is.na(actual_height), !is.na(actual_diameter)) %>%
  filter(actual_width != 0, actual_height != 0, actual_diameter != 0)

# Get unique type categories
type_categories <- unique(ceramics_clean$type_category)

# Create an empty list to store optimal cluster results
optimal_clusters <- list()

# Loop through each type category
for (type in type_categories) {
  cat("Analyzing:", type, "\n")
  
  # Subset data for the current type category
  subset_data <- ceramics_clean %>%
    filter(type_category == type)
  
  # Extract numeric variables for clustering
  numeric_data <- subset_data %>%
    select(actual_width, actual_height, actual_diameter)
  
  # Skip if not enough data points for clustering
  if (nrow(numeric_data) < 3) {
    cat("   Skipped:", type, " not enough data points (n =", nrow(numeric_data), ")\n\n")
    next
  }
  
  # Compute silhouette widths for k = 2 to up to nrow(numeric_data) - 1
  sil_width <- numeric()
  max_k <- min(10, nrow(numeric_data) - 1)
  
  for (k in 2:max_k) {
    pam_fit <- pam(numeric_data, k)
    sil_width[k] <- pam_fit$silinfo$avg.width
  }
  
  # Determine the optimal number of clusters (max silhouette width)
  best_k <- which.max(sil_width)
  
  # Store the result
  optimal_clusters[[as.character(type)]] <- best_k
  
  cat("   Optimal number of clusters for", type, ":", best_k, "\n\n")
}

# Print summary of results
cat(" Summary of optimal cluster numbers per type category:\n")
print(optimal_clusters)

```

``` {r, echo=TRUE}
library(dplyr)
library(cluster)
library(ggplot2)
library(purrr)

# --- Step 1: Clean the data ---
ceramics_clean <- ceramics_data %>%
  filter(!is.na(actual_width), !is.na(actual_height), !is.na(actual_diameter)) %>%
  filter(actual_width != 0, actual_height != 0, actual_diameter != 0)

# --- Step 2: Function to find optimal number of clusters using silhouette width ---
find_optimal_clusters <- function(df) {
  numeric_data <- df %>% select(actual_width, actual_height, actual_diameter)
  n <- nrow(numeric_data)
  if (n < 3) return(NA)  # Not enough points for clustering
  
  max_k <- min(10, n - 1)
  sil_values <- numeric(max_k)
  
  for (k in 2:max_k) {
    pam_fit <- pam(numeric_data, k)
    sil_values[k] <- pam_fit$silinfo$avg.width
  }
  
  best_k <- which.max(sil_values)
  return(best_k)
}

# --- Step 3: Compute optimal clusters per vessel type ---
optimal_clusters <- ceramics_clean %>%
  group_by(type_category) %>%
  summarise(
    n_datapoints = n(),
    optimal_k = find_optimal_clusters(cur_data())
  ) %>%
  ungroup()

# --- Step 4: Plot results ---
ggplot(optimal_clusters, aes(x = factor(type_category), y = optimal_k)) +
  geom_col(fill = "steelblue") +
  geom_text(aes(label = paste0("k=", optimal_k, "\n(n=", n_datapoints, ")")),
            vjust = -0.6, size = 3) +
  labs(
    title = "Optimal Number of Clusters using only size variables",
    x = "Vessel Type",
    y = "Optimal Cluster Count"
  ) +
  expand_limits(y = max(optimal_clusters$optimal_k, na.rm = TRUE) + 2) +  # add top space
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# --- Step 5: Print summary table ---
print(optimal_clusters)
```

# More detailed clustering including the three measured parameters + rim and base

I used PAM (Partitioning Around Medoids) clustering  also known as k-medoids  in combination with the Gower distance metric.

#Distance metric: Gower distance

Gower distance (via the daisy() function in Rs cluster package) allows you to mix:

Numeric variables (e.g., actual_width, actual_diameter, actual_height)

Categorical variables (e.g., rim_category, base_category)

It scales all variables automatically and computes pairwise dissimilarities between observations.

 Formula (simplified idea):
Each variable contributes between 0 and 1 to the distance, depending on whether two vessels differ (for categorical variables) or how far apart they are proportionally (for numeric variables).
Then these are averaged per pair of vessels.

This makes Gower ideal for archaeological datasets that mix quantitative and typological attributes

#PAM clustering

Clustering algorithm: PAM (Partitioning Around Medoids)

PAM is conceptually similar to k-means, but:

- It uses medoids (real observations) instead of centroids (mean points).

- It works with any distance matrix, including non-Euclidean ones like Gower.

- Its robust to outliers  very important when dealing with rare or atypical vessel types.

The code uses "pam(gower_dist, k)" which clusters the vessels based on their Gower dissimilarity matrix.

# Cluster analysis per vessel type including 'width, height, orifice, rim, base'

```{r, echo=TRUE}

# --- Load Libraries ---
library(dplyr)
library(cluster)
library(ggplot2)
library(purrr)
library(tidyr)

# Prepare data: clean zeros, NAs, and set up categorical variables
ceramics_filtered <- ceramics_data %>%
  mutate(
    across(c(actual_width, actual_diameter, actual_height), ~na_if(.x, 0)),
    rim_category = as.factor(rim_category),
    base_category = if_else(is.na(base_category) | base_category == "", "Bro", base_category),
    base_category = as.factor(base_category)
  ) %>%
  filter(!is.na(actual_width) & !is.na(actual_diameter) & !is.na(actual_height))

# Function to find optimal clusters (mixed numeric + categorical)
find_optimal_clusters_mixed <- function(df) {
  mixed_data <- df %>% select(actual_width, actual_diameter, actual_height, rim_category, base_category)
  gower_dist <- daisy(mixed_data, metric = "gower")
  max_k <- min(10, nrow(df) - 1)
  if (nrow(df) < 3) return(NA)
  
  sil_values <- map_dbl(2:max_k, function(k) {
    pam_fit <- pam(gower_dist, k)
    pam_fit$silinfo$avg.width
  })
  optimal_k <- which.max(sil_values) + 1
  return(optimal_k)
}

# Calculate optimal clusters per vessel type
optimal_clusters <- ceramics_filtered %>%
  group_by(type_category) %>%
  summarise(
    n_datapoints = n(),
    optimal_k = find_optimal_clusters_mixed(cur_data())
  ) %>%
  ungroup()

#  Assign clusters and list vessels, rim types, and base types
clustered_data <- ceramics_filtered %>%
  group_by(type_category) %>%
  group_modify(~{
    mixed_data <- .x %>% select(actual_width, actual_diameter, actual_height, rim_category, base_category)
    gower_dist <- daisy(mixed_data, metric = "gower")
    
    optimal_k <- find_optimal_clusters_mixed(.x)
    if (is.na(optimal_k) || optimal_k < 2) {
      .x$cluster <- 1
    } else {
      pam_fit <- pam(gower_dist, optimal_k)
      .x$cluster <- pam_fit$clustering
    }
    .x
  }) %>%
  ungroup()

#  Print summary table of clusters by site and vessel
cluster_summary <- clustered_data %>%
  group_by(site_name, type_category, cluster) %>%
  summarise(
    vessel_numbers = paste(unique(vessel_number), collapse = ", "),
    rim_types = paste(unique(rim_category), collapse = ", "),
    base_types = paste(unique(base_category), collapse = ", "),
    .groups = "drop"
  )

# Show the table in console
print(cluster_summary, n = Inf)

#  Plot: Optimal number of clusters per vessel type
ggplot(optimal_clusters, aes(x = factor(type_category), y = optimal_k)) +
  geom_col(fill = "steelblue") +
  geom_text(aes(label = paste0("k=", optimal_k, "\n(n=", n_datapoints, ")")),
            vjust = -0.6, fontface = "plain", size = 3) +
  labs(
    title = "Optimal Number of Clusters per Vessel Type",
    x = "Vessel Type",
    y = "Optimal Cluster Count"
  ) +
  expand_limits(y = max(optimal_clusters$optimal_k, na.rm = TRUE) + 2) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```
OBS: Try to make a cluster analysis on the collapsed rim types and compare it to above!

OBS: When there is no data on the base of the vessel then they are treated as having a round base (Bro)

# Cluster analysis per vessel type including size group, rim, base

```{r, echo=TRUE}

# --- Load Libraries ---
library(dplyr)
library(cluster)
library(ggplot2)
library(purrr)
library(tidyr)

library(dplyr)
library(cluster)
library(purrr)
library(ggplot2)

# --- Prepare data: clean categories ---
ceramics_cat <- ceramics_data %>%
  mutate(
    size_category = as.factor(size_category),
    rim_category  = as.factor(rim_category),
    base_category = if_else(is.na(base_category) | base_category == "", 
                            "Bro", base_category),   # Replace NA with "Bro"
    base_category = as.factor(base_category)
  )

# --- Function: determine optimal clusters for categorical data ---
find_optimal_clusters <- function(df) {
  
  cat_data <- df %>% select(size_category, rim_category, base_category)

  # Must have at least 3 rows to cluster
  if (nrow(cat_data) < 3) return(NA)

  # Compute Gower distance
  gower_dist <- daisy(cat_data, metric = "gower")

  max_k <- min(10, nrow(cat_data) - 1)

  sil_values <- map_dbl(2:max_k, function(k) {
    pam_fit <- pam(gower_dist, k)
    pam_fit$silinfo$avg.width
  })

  optimal_k <- which.max(sil_values) + 1
  return(optimal_k)
}

# --- Compute optimal clusters for each vessel type ---
optimal_clusters <- ceramics_cat %>%
  group_by(type_category) %>%
  summarise(
    n = n(),
    optimal_k = find_optimal_clusters(cur_data()),
    .groups = "drop"
  )

# --- Assign clusters per vessel type ---
clustered_data <- ceramics_cat %>%
  group_by(type_category) %>%
  group_modify(~{
    df <- .x %>% select(size_category, rim_category, base_category)

    # Find optimal k
    opt_k <- find_optimal_clusters(.x)

    # If too few rows, assign all to 1 cluster
    if (is.na(opt_k) || opt_k < 2) {
      .x$cluster <- 1
    } else {
      gower_dist <- daisy(df, metric = "gower")
      pam_fit <- pam(gower_dist, opt_k)
      .x$cluster <- pam_fit$clustering
    }

    .x
  }) %>%
  ungroup()

# --- Summary table of clusters ---
cluster_summary <- clustered_data %>%
  group_by(type_category, cluster) %>%
  summarise(
    vessels = paste(unique(vessel_number), collapse = ", "),
    rim_types = paste(unique(rim_category), collapse = ", "),
    base_types = paste(unique(base_category), collapse = ", "),
    size_categories = paste(unique(size_category), collapse = ", "),
    .groups = "drop"
  )

print(cluster_summary, n = Inf)

# --- Plot: optimal clusters per vessel type ---
ggplot(optimal_clusters, aes(x = factor(type_category), y = optimal_k)) +
  geom_col(fill = "steelblue") +
  geom_text(aes(label = paste0("k=", optimal_k, "\n(n=", n, ")")),
            vjust = -0.6, size = 3) +
  labs(
    title = "Optimal Number of Clusters per Vessel Type (size group, rim, base)",
    x = "Vessel Type",
    y = "Optimal k"
  ) +
  theme_minimal(base_size = 14) +
  expand_limits(y = max(optimal_clusters$optimal_k, na.rm = TRUE) + 2)

```

number of data points Comment:

< 10	Very risky  treat clusters as exploratory only
1030	Possible, but interpret very cautiously
3050	Can see preliminary structure, better if few clusters
50+	Solid for typical morphological clustering, more reliable

I set the limit to 10 - if I have fewer data points I must be very careful! 

Cluster analysis risk assessment:

GOOD (50+)

- Type 5
- Type 4
- Type 2

MEDIUM (30-50)

- Type 7
- Type 1

BAD (10-30)

- Type 6
- Type 10
- Type 3
- Type 9
- Type 8

VERY RISKY / Discarded (<10)

- Type 14 (+15)
- Type 11
- Type 13

#Type 1

```{r, echo=TRUE}

library(dplyr)
library(cluster)
library(ggplot2)

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 1  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

# Type 2

```{r, echo=TRUE}

library(dplyr)
library(cluster)
library(ggplot2)

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 2  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

# Type 3

```{r, echo=TRUE}

library(dplyr)
library(cluster)
library(ggplot2)

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 3  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

Interpretaion:

# Type 4

```{r, echo=TRUE}

library(dplyr)
library(cluster)
library(ggplot2)

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 4  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

# Type 5

```{r, echo=TRUE}

library(dplyr)
library(cluster)
library(ggplot2)

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 5  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

#Type 6

```{r, echo=TRUE}

library(dplyr)
library(cluster)
library(ggplot2)

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 6  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation: I do not know if 8 clusters are the correct number..

# Type 7

```{r, echo=TRUE}

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 7  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

# Type 8

```{r, echo=TRUE}

library(dplyr)
library(cluster)
library(ggplot2)

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 8  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

# Type 9

```{r, echo=TRUE}

library(dplyr)
library(cluster)
library(ggplot2)

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 9  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation:

# Type 10

```{r, echo=TRUE}

library(dplyr)
library(cluster)
library(ggplot2)

# --- Step 1: Filter for one vessel type ---
vessel_type_selected <- 10  # change this to analyze another vessel type

ceramics_subset <- ceramics_data %>%
  filter(type_category == vessel_type_selected) %>%
  mutate(
    base_category = ifelse(is.na(base_category), "Bro", base_category),  # Treat NA as "Bro" (round)
    actual_width = na_if(actual_width, 0),
    actual_diameter = na_if(actual_diameter, 0),
    actual_height = na_if(actual_height, 0),
    litres = na_if(litres, 0),
    litres = round(litres, 2),
    rim_category = as.factor(rim_category),
    base_category = as.factor(base_category)
  ) %>%
  drop_na(actual_width, actual_diameter, actual_height)

# --- Step 2: Compute Gower distance for mixed data ---
gower_dist <- daisy(
  ceramics_subset[, c("actual_width", "actual_diameter", "actual_height", "rim_category", "base_category")],
  metric = "gower"
)

# --- Step 3: Determine optimal number of clusters (210) ---
sil_widths <- numeric(10)
for (k in 2:10) {
  pam_fit <- pam(gower_dist, diss = TRUE, k = k)
  sil_widths[k] <- pam_fit$silinfo$avg.width
}
optimal_k <- which.max(sil_widths)
cat("Optimal number of clusters:", optimal_k, "\n")

# --- Step 4: Perform clustering using optimal k ---
final_pam <- pam(gower_dist, diss = TRUE, k = optimal_k)
ceramics_subset$cluster <- as.factor(final_pam$clustering)

# --- Step 5: Print detailed cluster summary table ---
cluster_summary <- ceramics_subset %>%
  select(vessel_number, site_name, rim_category, base_category, cluster) %>%
  arrange(cluster, site_name)

cat("\n=== Cluster Summary Table ===\n")
print(cluster_summary, n = nrow(cluster_summary))

# --- Step 6: Cluster dependency profiles (means, medians, minmax, etc.) ---
cluster_profiles <- ceramics_subset %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    mean_width = mean(actual_width, na.rm = TRUE),
    median_width = median(actual_width, na.rm = TRUE),
    min_width = min(actual_width, na.rm = TRUE),
    max_width = max(actual_width, na.rm = TRUE),
    sd_width = sd(actual_width, na.rm = TRUE),

    mean_diameter = mean(actual_diameter, na.rm = TRUE),
    median_diameter = median(actual_diameter, na.rm = TRUE),
    min_diameter = min(actual_diameter, na.rm = TRUE),
    max_diameter = max(actual_diameter, na.rm = TRUE),
    sd_diameter = sd(actual_diameter, na.rm = TRUE),

    mean_height = mean(actual_height, na.rm = TRUE),
    median_height = median(actual_height, na.rm = TRUE),
    min_height = min(actual_height, na.rm = TRUE),
    max_height = max(actual_height, na.rm = TRUE),
    sd_height = sd(actual_height, na.rm = TRUE),
    
    mean_litres = mean(litres, na.rm = TRUE),
    median_litres = median(litres, na.rm = TRUE),
    min_litres = min(litres, na.rm = TRUE),
    max_litres = max(litres, na.rm = TRUE),
    sd_litres = sd(litres, na.rm = TRUE),

    most_common_rim = names(sort(table(rim_category), decreasing = TRUE))[1],
    most_common_base = names(sort(table(base_category), decreasing = TRUE))[1]
  )

cat("\n=== Cluster Dependency Summary ===\n")
print(cluster_profiles, n = nrow(cluster_profiles))

# --- Step 7: Visualize clusters ---
ggplot(ceramics_subset, aes(x = actual_width, y = actual_height, color = cluster)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    title = paste("Cluster Analysis for Vessel Type", vessel_type_selected),
    subtitle = paste("Optimal clusters (k) =", optimal_k),
    x = "Actual Width (cm)",
    y = "Actual Height (cm)",
    color = "Cluster"
  ) +
  theme_minimal(base_size = 13)

```

Interpretation: The Jenne-jeno vessels are in their own cluster -> used for graves!


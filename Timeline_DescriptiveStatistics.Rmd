---
title: "Timeline_DescriptiveStatistics"
author: "Soren Pedersen"
date: "2024-11-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. 

--------------------------------------------------------------------------------

### IDEAS FOR THIS DOCUMENT ###

To better understand my data I have made a document to explore the data:

- which rim type is most popular overall? -DONE-
- which rim type is most popular per site? -DONE-
- which rim type is most popular through time?

- which base type is most popular overall? -DONE-
- which base type is most popular per site? -DONE- (but not as three plots)
- which base type is most popular through time?

- Which vessel type is most dominant overall? -DONE-
- Which vessel type is most dominant per site? -DONE-
- Which vessel type is most dominant through time?

- What size category is dominant overall? -DONE-
- What size category is dominant per site? -DONE- (but not as three plots)
- What size category is dominant through time?

- What attribute category is dominant overall? -DONE-
- What attribute category is dominant per site?
- What attribute category is dominant through time?

- What decoration category is dominant overall?
- What decoration category is dominant per site?
- What decoration category is dominant through time?

-----------------------------------------
### STEP 0: Install and load packages ###
-----------------------------------------

```{r, echo=TRUE}

# Install necessary packages:

# install.packages("readxl")    # For reading Excel files
# install.packages("dplyr")
# install.packages("ggplot2")
# install.packages("factoextra") # For visualizing clusters
# install.packages("cluster")
# install.packages("ggplot2")
# install.packages("cowplot")
# install.packages("tidyr")
# install.packages("stringr")
# install.packages("openxlsx")
# install.packages("vcd")
# install.packages("reshape2")
# install.packages("devtools")
# install.packages("rrtools")
# install.packages("remotes")
# install.packages("viridis")

# Load necessary libraries:

library(devtools)
#library(rrtools)
library(remotes)
library(readxl)
library(dplyr)
library(ggplot2)
library(factoextra)
library(cluster)
library(cowplot)
library(tidyr)
library(stringr)
library(openxlsx)
library(vcd)
library(reshape2)
library(viridis)

```

--------------------------------------------------------------------------------
# STEP 0: Load data (Skip if you have already loaded the data in previous steps)
--------------------------------------------------------------------------------

# Load data

The data is named data_measurements01.xlsx from the previous step. 

```{r, echo=TRUE}

# Load your dataset from an Excel file
ceramics_data <- read_excel("analysis/data/raw_data/data_measurements_01.xlsx")

# Ensure your Excel file has columns: actual_diameter, actual_width, actual_height
# Check the first few rows of your data
head(ceramics_data)

```

-----------------------------------------------------
# STEP 1: Make a dataset for the descriptive analysis
-----------------------------------------------------

- I made a new data set only including the "site_name", "type_category", "size_category", ""rim_category", "base_category", "attributes", "actual_diameter", "actual_height", "actual_width"
- (NOT: I removed rows with missing values in the "actual_diameter" column (registered as 0.0 in the excel sheet))
- This dataset it used for making the following "nice" boxplots!

```{r, echo=TRUE}
ceramics_subset <- ceramics_data %>%
#  filter(actual_diameter != 0.0) %>%   #Only filter the 0,0s later!
  select(site_name, type_category, size_category, rim_category, base_category, 
         attributes, actual_diameter, actual_height, actual_width)

```

So, now I created a data set "ceramics_subset" of the columns noted above (NOT: and removed rows from the "actual_diameter" column that contained 0.0 values). Tha dataset still contains the original 611 vessels.

---------------------------------------------------------
# Step 2: Boxplot of data points per vessel type category
---------------------------------------------------------

```{r, echo=TRUE}
# Used libraries
#library(ggplot2)

# Barplot of 'Counts per Type Category' 

# Drop NAs and count data points per type category
summary_counts_vessel <- ceramics_data %>%
  drop_na(type_category) %>%
  count(type_category, name = "Count")

# Calculate total number of data points (all rows after removing NAs)
total_points_vessel <- nrow(ceramics_data %>% drop_na(type_category))

# Plot the counts with total as a label inside the plot
ggplot(summary_counts_vessel, aes(x = type_category, y = Count)) +
  geom_bar(stat = "identity") +
  annotate("text", x = Inf, y = Inf, label = paste("Total:", total_points_vessel),
           hjust = 1.1, vjust = 2, size = 5, fontface = "bold", color = "black") +
  labs(
    x = "vessel type Category",
    y = "Count",
    title = "Counts per Type Category"
  ) +
  theme_minimal()

```
Very nice!

```{r, echo=TRUE}
# Used libraries:
#library(ggplot2)
#library(cowplot)

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each vessel type
vessel_counts <- data.frame(table(ceramics_subset$type_category))   #make a data set of type_category and the counts per category
colnames(vessel_counts) <- c("type_category", "count")    #name the columns in vessel_counts

# Calculate total number of data points
total_vessels <- sum(vessel_counts$count)

# Create the bar plot of 'Data points per vessel type'
bar_plot_vessel <- ggplot(vessel_counts, aes(x = as.factor(type_category), y = count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Vessel Type",
       x = "Vessel Type",
       y = "Number of Data Points") +
  annotate("text", 
           x = Inf, y = Inf, 
           label = paste("Total =", total_vessels), 
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for vessel type descriptions
legend_table_vessel <- data.frame(
  type_category = 1:15,
  Description = c("Wide-open vessels", "Open vessels", "Closed horizontal-oval vessels", 
                  "Vertical vessels", "Closed vessels", "Tightly-closed vessels", 
                  "Open carinated vessels", "Wide-open carinated vessels", 
                  "Vertical-vertical oval vessels", "Closed-vertical oval vessels", 
                  "Tightly-closed vertical oval vessels", "Lids", 
                  "Flasks", "Bottles", "Tellem tripods")
)

# Convert the legend table to a plot with adjusted margins
legend_plot_vessel <- ggplot(legend_table_vessel, aes(x = "", y = type_category, label = paste(type_category, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side
cowplot::plot_grid(bar_plot_vessel, legend_plot_vessel, ncol = 2, rel_widths = c(3, 1.5))

```
This plot looks nice! It includes all the 611 vessels.

NIck (DONE): You need a barplot here, change geom_boxplot() to geom_bar()

# PRELIM interpretation:

- Vessel category 5 (closed vessels) has by far the most data points -> interesting because it also has the most multi purpose function!!!
- 2nd most data point are vessel category 4 (vertical vessels) -> also interesting because I think this is also a very multi purpose vessel!!!
- 3rd most data point are vessel category 2 (open vessels)
- 4th most data point are vessel category 7 (Open carinated vessels)
- 5th most data point are vessel category 1 (wide-open vessels)
- 6th most data point are vessel category 15 (Tellem tripods)
- 7th and 8th most data point are vessel category 3 (closed horizontal-oval vessels) and 10 (closed vertical-oval vessels)
- 9th most data point are vessel category 6 (tightly-closed vessels)
- 10th most data point are vessel category 8 (wide-open carinated vessels)
- 11th most data point are vessel category 9 (Vertical vertical-oval vessels)
- 12th most data point are vessel category 11 (tightly-closed vertical oval vessels)
- 13th most data point are vessel category 14 (bottles)
- 14th most data point are vessel category 13 (flasks)
- vessel category 12 is left out because there are no data points (lids)

- There is actually a correlation between how "multi-purpose" a vessel is and the amount of data points I have collected. The "closed vessels", "vertical vessels" and the "open vessels" are the three categories you can describe as the most multi-purpose!

-NICK/me: this also points to the conservationism of the pottery, in where the oldest forms are also the most numerous. They do not change the pottery types so often!

---------------------------------------------------------------
# STEP 3: Barplot of how many datapoint I have per rim category
---------------------------------------------------------------

```{r, echo=TRUE}
# Used libraries
#library(ggplot2)

# Barplot of 'Counts per Rim Category' 

# Drop NAs and count data points per rim category
summary_counts_rim <- ceramics_data %>%
  drop_na(rim_category) %>%
  count(rim_category, name = "Count")

# Calculate total number of data points (all rows after removing NAs)
total_points_rim <- nrow(ceramics_data %>% drop_na(rim_category))

# Plot the counts with total as a label inside the plot
ggplot(summary_counts_rim, aes(x = rim_category, y = Count)) +
  geom_bar(stat = "identity") +
  annotate("text", x = Inf, y = Inf, label = paste("Total:", total_points_rim),
           hjust = 1.1, vjust = 2, size = 5, fontface = "bold", color = "black") +
  labs(
    x = "Rim Category",
    y = "Count",
    title = "Counts per Rim Category"
  ) +
  theme_minimal()

```

Let's try to make the plot nicer

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each vessel type
rim_counts <- data.frame(table(ceramics_data$rim_category))
colnames(rim_counts) <- c("rim_category", "Count")

# Calculate total number of rim data points
total_rims <- sum(rim_counts$Count)

# Create the bar plot of 'Data points per vessel type' with total count
bar_plot_rim <- ggplot(rim_counts, aes(x = as.factor(rim_category), y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Rim Type",
       x = "Rim Type",
       y = "Number of Data Points") +
  annotate("text", 
           x = Inf, y = Inf, 
           label = paste("Total =", total_rims), 
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for vessel type descriptions
legend_table_rim <- data.frame(
  Rim_Type = 1:27,
  Abbreviation = c("Sr", "Sp", "Sf", "Sb", "Es", "Ec", "Ecc", "Ef", "Efl", "Ep", 
                   "Et", "Esg", "Emg", "Vs", "Vc", "Oth", "Otc", "Otf", "Ith", 
                   "Itc", "Itf", "Th", "Tc", "Tf", "Ca", "I", "Y"),
  Description = c("Simple, rounded", "Simple, pointy", "Simple, flattened", 
                  "Simple, bevelled", "Everted, simple", "Everted, collared", 
                  "Everted, collared channelled", "Everted, flaring", 
                  "Everted, flattened", "Everted, protruding", 
                  "Everted, thickened", "Everted, single groove", 
                  "Everted, multiple groove", "Vertical, simple", "Vertical, collared", 
                  "Outward thickened, hinged", "Outward thickened, curved", 
                  "Outward thickened, flattened", "Inwards thickened, hinged",
                  "Inwards thickened, curved", "Inwards thickened, flattened",
                  "Thickened, hinged", "Thickened, curved", "Thickened, flattened",
                  "Carinated", "Inverted", "Y-rims")
)

# Convert the legend table to a plot with adjusted margins and abbreviations
legend_plot_rim <- ggplot(legend_table_rim, aes(x = "", y = Rim_Type, label = paste(Abbreviation, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side with adjusted widths
cowplot::plot_grid(bar_plot_rim, legend_plot_rim, ncol = 2, rel_widths = c(3, 1.5))

```
So, this looks damn good! 

# PRELIM interpretation of trial data:

- The Sr (Simple Rounded) category is by far the most represented, as expected! Perhaps you can also say that this category is very multi-purpose because it does not include or exclude any functions?

- The Es (Everted Simple) category is the 2nd highest represented. This is also one of the earliest categories of rims (after the Sr, and 'thickened' categories). This rim category is for handling the vessel, to fasten a cloth and string around to close the vessel, or to pour from.

- The Otc (Outwards Thickened, curved) is the 3rd highest category and also the 2nd earliest rim type - if I remember correctly! This type is for handling the vessel (not hot vessel!), close the vessel with string and cloth, or to reinforce the rim.

- The Itc (Inwards Thickened, curved) is the 4th highest category. This category is also for handling the vessel or to reinforce the rim.

- The Sf (Simple, flattened) rim are the 5th highest category, and there is perhaps not so much function in this rim. Perhaps you can easier stack the vessels, but I think it is mosly for appearence. 

- The Oth (Outwards thickened, hinged) rims are the 6th highest category, and here the rim is for grabbing or reinforcing the vessel, but because it has a sharp corner under the rim then perhaps it is better suited for closing the vessel with cloth and string. This can also be an over-interpretation and the sharp corner under the rim can be just for aesthetics, or for a better grip?.

- The 7th and 8th highest categories are the Sb (Simple, beveled) and Sp (Simple, pointy) categories. I think these categories are mostly for aesthetics, but there can be some stacking functions in these

- the 9th highest category is the Tc (Thickened, curved) category, where this is for grapping or reinforcing the vessel. 

- The rest of the categories are quite evenly represented!

I want to collapse the different rim categories into more manageable categories. 

```{r, echo=TRUE}

# Collapse rim categories by first letter and count them
rim_counts_collapsed <- ceramics_data %>%
  filter(!is.na(rim_category)) %>%
  mutate(rim_group = case_when(
    grepl("^S", rim_category) ~ "Simple rims",
    grepl("^E", rim_category) ~ "Everted rims",
    grepl("^V", rim_category) ~ "Vertical rims",
    grepl("^O", rim_category) ~ "Outwards th. rims",
    grepl("^I", rim_category) ~ "Inwards th. rims",
    grepl("^T", rim_category) ~ "Thickened rims",
    grepl("^C", rim_category) ~ "Carinated rims",
    rim_category == "Y" ~ "Y-rims",
    TRUE ~ "Other"
  )) %>%
  group_by(rim_group) %>%
  summarise(Count = n(), .groups = "drop")

# Total number of rim data points
total_rims <- sum(rim_counts_collapsed$Count)

# Bar plot without legend
bar_plot_rim_collapsed <- ggplot(rim_counts_collapsed, aes(x = rim_group, y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Collapsed Rim Type",
       x = "Rim Group",
       y = "Number of Data Points") +
  annotate("text", 
           x = Inf, y = Inf, 
           label = paste("Total =", total_rims), 
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10),
    legend.position = "none"
  )

bar_plot_rim_collapsed

```

Collapsing the data might help understand the rim types!

----------------------------------------------------------------
# STEP 4: Boxplot of how many datapoint I have per base category
----------------------------------------------------------------

```{r, echo=TRUE}

# Used libraries
#library(ggplot2)
#library(tidyr)

# Boxplot of 'Counts per Base Category' 
ceramics_subset %>% 
  drop_na(base_category) %>%  #Drop NAs in 'base_category'
ggplot(aes(x = base_category)) +
  geom_bar() +
  labs(x = "Base Category", y = "Count", title = "Counts per Base Category") +
  theme_minimal()

```
So, this looks nice !

Let's try to make the plot nicer

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each base type
base_counts <- data.frame(table(ceramics_subset$base_category))
colnames(base_counts) <- c("base_category", "Count")

# Calculate total number of base data points
total_base <- sum(base_counts$Count)

# Create the bar plot of 'Data points per base type' with total count
bar_plot_base <- ggplot(base_counts, aes(x = as.factor(base_category), y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Base Type",
       x = "Base Type",
       y = "Number of Data Points") +
  annotate("text",
           x = Inf, y = Inf,
           label = paste("Total =", total_base),
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for base type descriptions
legend_table_base <- data.frame(
  Base_Type = 1:9,
  Abbreviation = c("Bf", "Br", "Bpe", "Bl", "Bc", "Bpo", "Sp", "Bro", "Bt"),
  Description = c("Bases, flat", "Bases, ring", "Bases, pedestal", 
                  "Bases, legged", "Bases, concave", "Bases, pointy", "Special", 
                  "Bases, rounded", "Bases, tripod")
)

# Convert the legend table to a plot with adjusted margins
legend_plot_base <- ggplot(legend_table_base, aes(x = "", y = Base_Type, label = paste(Abbreviation, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side
cowplot::plot_grid(bar_plot_base, legend_plot_base, ncol = 2, rel_widths = c(3, 1.5))

```
So, this plot looks nice! It only includes the vessels that have a registered base, so NA's are excluded!

Rounded bases are only included in the registration if the vessel was fully reconstructed

OBS: I need to include the registrations I have from the excavation reports I have in the RAW database in the final presentation!

#PRELIM interpretation of trial data:

- Most of the bases are NA because nothing was registered
- Bpe (Base, pedestalled) are the category with most data points -> in this category we also have the Tellem tripods base - perhaps I need to make a separate category for that!
- Br (Bases, ring) are the 2nd highest category
- Bf (Bases flat) are the 3rd highest category
- Bpo (Bases, pointy) are the 4th highest category
- Bl (Bases, legged) I think only has one count (jenne-jeno)
- Special -> I must find out what is the special category!

----------------------------------------------------------------
# STEP 5: Boxplot of how many datapoint I have per size cateogry
----------------------------------------------------------------

```{r, echo=TRUE}
ceramics_data %>% 
drop_na(size_category) %>% 
ggplot(aes(x = size_category)) +
  geom_bar() +
  labs(x = "Size Category", y = "Count", title = "Counts per Size Category") +
  theme_minimal()
```
Very nice! As expected I have the most vessels in size category "b", but surprising is that the small size category "a" is so dominant.

Let's try to make the plot a little nicer

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each size category
size_counts <- data.frame(table(ceramics_subset$size_category))
colnames(size_counts) <- c("size_category", "Count")

# Calculate total number of size data points
total_size <- sum(size_counts$Count)

# Create the bar plot of 'Data points per size category' with total count
bar_plot_size <- ggplot(size_counts, aes(x = as.factor(size_category), y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Size Category",
       x = "Size Category",
       y = "Number of Data Points") +
  annotate("text",
           x = Inf, y = Inf,
           label = paste("Total =", total_size),
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for size type descriptions
legend_table_size <- data.frame(
  Size_Type = 1:5,
  Abbreviation = c("a", "b", "c", "d", "e"),
  Description = c("<14.9 cm", "15-24.9 cm", "25-34.9 cm", "35-44.9 cm", ">45 cm")
)

# Convert the legend table to a plot with adjusted margins and abbreviations
legend_plot_size <- ggplot(legend_table_size, aes(x = "", y = Size_Type, label = paste(Abbreviation, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side
cowplot::plot_grid(bar_plot_size, legend_plot_size, ncol = 2, rel_widths = c(3, 1.5))


```
So, this looks very nice!

# Interpretation of the 02_timelinedata results

OBS: Remember that the size categories are based on the "actual_width" of the vessels and NOT something like volume

- Surprising that the "a" size category is so dominant. This is perhaps because the small vessels are often dropped or broken?? 14.9 cm (the largest vessels in this category) might be used for cooking also, but by far the most vessels are small short-term storage pots, or perhaps special vessels for casting or salt making??

- As expected, the size category "b" is the most dominant vessel size. In this category you would expect to find the "normal" cooking vessels and vessels that are more or less multi-purpose.

- As expected, the size category "c" is dominant, but only third most dominant after the size "a" groups (slightly). In this category I would expect that many of the "wide-open vessels" are represented, and otherwise many sort- to medium-term storage vessels.

- As expected, the size "d" vessels are not so dominant. In this category I would expect to find the long-term storage vessels, fermenting/brewing vessels, and many of the large "wide-open" vessels.

- As expected, the size cateogry "e" is the least dominant. I this category I would expect to find the very large "wide-open" vessels, and otherwise vessels that are highly specialized like large brewing vessels or special long-term storage vessels (perhaps to be dug into the ground?).

---------------------------------------------------------------------
# STEP 6: Boxplot of how many datapoint I have per attribute cateogry
---------------------------------------------------------------------

Simple boxplot

```{r, echo=TRUE}
ceramics_data %>% 
drop_na(attributes) %>% 
ggplot(aes(x = attributes)) +
  geom_bar() +
  labs(x = "Attribute Category", y = "Count", title = "Counts per Attribute Category") +
  theme_minimal()
```
looks nice! 

I must specify that these attributes are only found on the reconstructed vessels, and more attributes have been registered in the publications -> registered in my second excel sheet

I must also specify that these attributes are only the ones that are suspected to be funcitonal!

Let's make the plot nicer

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(cowplot)

# Create a data frame to count the number of data points for each vessel type
attribute_counts <- data.frame(table(ceramics_subset$attributes))
colnames(attribute_counts) <- c("attributes", "Count")

# Calculate total number of attribute data points
total_attributes <- sum(attribute_counts$Count)

# Create the bar plot of 'Data points per attribute' with total count
bar_plot_attribute <- ggplot(attribute_counts, aes(x = as.factor(attributes), y = Count)) +
  geom_col(fill = "lightblue") +
  labs(title = "Number of Data Points per Attribute Category",
       x = "Attribute Category",
       y = "Number of Data Points") +
  annotate("text",
           x = Inf, y = Inf,
           label = paste("Total =", total_attributes),
           hjust = 1.1, vjust = 2, size = 4, fontface = "bold") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 10, 10, 10)
  )

# Legend table for vessel type descriptions
legend_table_attribute <- data.frame(
  Attribute_Type = 1:5,
  Abbreviation = c("H", "Sp", "St", "K", "Pl"),
  Description = c("Handles", "Spouts", "Steamers", "Knobs", "Plastic Band")
)

# Convert the legend table to a plot with adjusted margins and abbreviations
legend_plot_attribute <- ggplot(legend_table_attribute, aes(x = "", y = Attribute_Type, label = paste(Abbreviation, "=", Description))) +
  geom_text(hjust = 0, size = 3) +
  theme_void() +
  theme(
    plot.margin = margin(5, 20, 5, -140)
  )

# Arrange the bar plot and the legend side by side with adjusted widths
cowplot::plot_grid(bar_plot_attribute, legend_plot_attribute, ncol = 2, rel_widths = c(3, 1.5))


```
Looks perfect!


--------------------------------------------------------------------------------
## DATA PER SITE ##
-------------------

---------------------------------------------
# STEP 1: Plot of vessel type counts per site
---------------------------------------------

The following analysis explores which vessel types are dominant per site.

# STEP 01: Plot each site individually with vessel type counts

OBS: "VS01" which is the addition to the data tables I produce refers to "Vessel - Site" and data table 01 (ex: data_count_VS01)

```{r, echo=TRUE}

# Load required libraries
#library(ggplot2)
#library(dplyr)
#library(viridis)

# Load required libraries
#library(ggplot2)
#library(dplyr)
#library(viridis)

# Assuming your dataset is named 'ceramics_subset' with columns 'site_name' and 'type_category'
# Count the occurrences of type_category per site
data_count_VS01 <- ceramics_subset %>%
  group_by(site_name, type_category) %>%
  summarise(count = n(), .groups = 'drop')

# Add a mapping of type_category to type descriptions (example mapping)
type_descriptions_VS01 <- data.frame(
  type_category = as.character(1:15),
  type_description = c("1- Wide-open globular", "2- Open globular", "3- Closed hor. oval", "4- Vertical globular", "5- Closed globular", 
                       "6- Tightly-closed globular", "7- Open carinated", "8- Wide-open carinated", "9- Vertical ver. oval", "10- Closed ver. oval", 
                       "11- Tightly-closed ver. oval", "12- Lids (NOT plottet)", "13- Flasks", "14- Bottles", "15- Tellem tripods")
)

# Make sure the "type_category" columns are both character columns
data_count_VS01$type_category <- as.character(data_count_VS01$type_category)
type_descriptions_VS01$type_category <- as.character(type_descriptions_VS01$type_category)

# Merge descriptions into the data
data_count_VS01 <- data_count_VS01 %>%
  left_join(type_descriptions_VS01, by = "type_category")

# Ensure the x-axis (type_category) and legend are in numeric order
data_count_VS01 <- data_count_VS01 %>%
  mutate(type_category = factor(type_category, levels = as.character(1:15)),
         type_description = factor(type_description, levels = type_descriptions_VS01$type_description))

# Create a function to generate a plot for a single site
plot_site_VS01 <- function(site_name) {
  site_data <- data_count_VS01 %>% filter(site_name == !!site_name)
  
  ggplot(site_data, aes(x = type_category, y = count, fill = type_description)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_viridis(discrete = TRUE, option = "D") +
    theme_minimal() +
    labs(
      title = paste("Vessel Types at Site:", site_name),
      x = "Type Category",
      y = "Count",
      fill = "Type Category"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Get unique site names
site_names_VS01 <- unique(data_count_VS01$site_name)

# Generate and print plots for each site
for (site in site_names_VS01) {
  print(plot_site_VS01(site))
}
```

Damn this looks good! But you should determine a specific colour to each vessel shape. Right now it changes from one plot to the next

OBS: Some sites have decimal numbers and I do not really know why. The plots should only represent whole numbers. The sites are: Dhar Tichitt, Dia Mara, Korounkorokale, Sadia. 


# Interpretation of the results (from most to least vessel types)

Akumbu: 10 vessel types are represented, where the dominant is cat. 5, followed by 4 and 6. So, quite many storage vessels at Akumbu

Jenne-jeno: 10 vessel types are represented, where the dominant is cat. 7 the carinated vessels, followed by cat. 5. Also the cat. 1 and 2 vessels are quite numerous, and together the "wide-open" and "open" vessels are very dominant. Does this talk into presenting food and symposiums??? 

Koumbi Saleh: 10 vessel types are represented, where the dominant is cat. 4 followed by 5, 9, 10 (the tall-ovoid types)

T. Doupville/Galia: 10 vessel types are represented where the most dominant is cat. 4 followed by 2, 3, 10. NO vessel cat. 5 (surprise)!

Dangandouloun: 7 vessel types are represented, where the dominant is cat. 15, followed by 5, 4, 6, and 7. Again quite many storage vessels

Dia Shoma: 7 vessel types are represented, where the dominant is cat. 3 and 10.

Gao Saney: 7 vessel types are represented, where the dominant is cat. 2 the open vessels (surprise?), followed by cat. 4 and 5

Winde Koroji: 7 vessel types are represented where the most dominant is cat. 4, followed by 3, 5. 

KNTII: 6 vessel types are represented, where the dominant is cat. 5 followed by 4. 

Karkarichinkat: 6 vessels are represented, where the dominant is cat. 5 followed by 2. Quite many cat. 6 sotrage vessels are also represented

Pegue A: 6 vessel types are represented, where the dominant is cat. 5 followed by 15 and 4 (many Tellem tripods -> site specialization?)

Timbuktu: 6 vessel types are represented, where the dominant is cat. 5 followed by 7 and 4

Kobadi: 5 vessel types are represented, where the dominant is cat. 5 followed by 1 and 4

Ounjougou: 5 vessels are represented, BUT there is a problem that the site is presented from 3 timeslizes. The most dominant is cat. 4

Sadia: 5 vessel types are represented, where the most dominant is cat. 5 followed by 4

Toubel: 5 vessel types are represented where the dominant is cat. 5 followed by 2.

Dia Mara: 4 vessel types are represented, but NO number 5. No dominant vessel type

Dourou-boro: 4 vessel types are represented, where the two dominant are cat. 4 and 5

Dhar Tichitt: 3 vessel types are represented where the dominant is cat. 5

Korounkorokale: 3 vessel types are represented, where the dominant is cat. 4

Mema: 3 vessel types are represented, where the dominant is cat. 5

OBS: I need to divide them into time phases, because right now I only see all the phases represented in one plot. I need to think about that.

So, there is a difference of how many vessel types are represented at the sites, where Akumbu, Jenne-jeno, Koumbi Saleh, and T. Doupville/Galia all have 10 vessel types at the most. What is common from these sites? I think they are all hubs and "urbanized" but is there something else in common???

# STEP 02: Plot all the sites in three diagrams with the different vessel types represented

OBS: "VS02" which is the addition to the data tables I produce refers to "Vessel - Site" and datatable 02 (ex: data_count_VS02)

The plots are so large that I need to print them in three plots

#Prepare data for three plots

```{r, echo=TRUE}

# Assuming your dataset is named 'ceramics_subset' with columns 'site_name' and 'type_category'
# Count the occurrences of type_category per site
data_count_VS02 <- ceramics_subset %>%
  group_by(site_name, type_category) %>%
  summarise(count = n(), .groups = 'drop')

# Add a mapping of type_category to type descriptions (example mapping)
type_descriptions_VS02 <- data.frame(
  type_category = as.character(1:15),
  type_description = c("1- Wide-open globular", "2- Open globular", "3- Closed hor. oval", "4- Vertical globular", "5- Closed globular", 
                       "6- Tightly-closed globular", "7- Open carinated", "8- Wide-open carinated", "9- Vertical ver. oval", "10- Closed ver. oval", 
                       "11- Tightly-closed ver. oval", "12- Lids (NOT plotted)", "13- Flasks", "14- Bottles", "15- Tellem tripods")
)

# Ensure the type_category columns are both character columns
data_count_VS02$type_category <- as.character(data_count_VS02$type_category)
type_descriptions_VS02$type_category <- as.character(type_descriptions_VS02$type_category)

# Merge descriptions into the data
data_count_VS02 <- data_count_VS02 %>%
  left_join(type_descriptions_VS02, by = "type_category")

# Ensure the x-axis (type_category) and legend are in numeric order
data_count_VS02 <- data_count_VS02 %>%
  mutate(type_category = factor(type_category, levels = as.character(1:15)),
         type_description = factor(type_description, levels = type_descriptions_VS02$type_description))

# Pivot the data to wide format: Each type_category becomes a separate column
data_wide_VS02 <- data_count_VS02 %>%
  select(-type_description) %>% # Exclude type_description for the wide format
  pivot_wider(names_from = type_category, values_from = count, values_fill = list(count = 0))

# Reshape the data back to long format for plotting
data_long_VS02 <- data_wide_VS02 %>%
  pivot_longer(cols = -site_name, names_to = "type_category", values_to = "count") %>%
  mutate(type_category = factor(type_category, levels = as.character(1:15))) # Restore factor order

# Merge back the type descriptions for plotting
data_long_VS02 <- data_long_VS02 %>%
  left_join(type_descriptions_VS02, by = "type_category")

```

#Make data tables for three plots

```{r, echo=TRUE}

# Split the data into three halves based on the site_name
third_size_VS02 <- floor(n_distinct(data_long_VS02$site_name) / 3)
site_names_first_third_VS02 <- unique(data_long_VS02$site_name)[1:third_size_VS02]
site_names_second_third_VS02 <- unique(data_long_VS02$site_name)[(third_size_VS02 + 1):(2 * third_size_VS02)]
site_names_third_third_VS02 <- unique(data_long_VS02$site_name)[(2 * third_size_VS02 + 1):length(unique(data_long_VS02$site_name))]

# Subset the data for each third of site names
data_first_third_VS02 <- data_long_VS02 %>%
  filter(site_name %in% site_names_first_third_VS02)

data_second_third_VS02 <- data_long_VS02 %>%
  filter(site_name %in% site_names_second_third_VS02)

data_third_third_VS02 <- data_long_VS02 %>%
  filter(site_name %in% site_names_third_third_VS02)

# Ensure numeric order for type_category and include descriptions
data_first_third_VS02 <- data_first_third_VS02 %>%
  mutate(
    type_category = factor(type_category, levels = as.character(1:15)),
    type_description = factor(type_description, levels = type_descriptions_VS02$type_description)
  )

data_second_third_VS02 <- data_second_third_VS02 %>%
  mutate(
    type_category = factor(type_category, levels = as.character(1:15)),
    type_description = factor(type_description, levels = type_descriptions_VS02$type_description)
  )

data_third_third_VS02 <- data_third_third_VS02 %>%
  mutate(
    type_category = factor(type_category, levels = as.character(1:15)),
    type_description = factor(type_description, levels = type_descriptions_VS02$type_description)
  )

# Plot 1: First third of the sites
plot1_VS02 <- ggplot(data_first_third_VS02, aes(x = site_name, y = count, fill = type_description)) +
  geom_bar(stat = "identity", position = "dodge") +  # Position bars side by side
  scale_fill_viridis(discrete = TRUE, option = "D") +  # Viridis palette
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Vessel Type Categories pr. Site (1/3)",
    fill = "Type Description"  # Updated legend title
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Plot 2: Second third of the sites
plot2_VS02 <- ggplot(data_second_third_VS02, aes(x = site_name, y = count, fill = type_description)) +
  geom_bar(stat = "identity", position = "dodge") +  # Position bars side by side
  scale_fill_viridis(discrete = TRUE, option = "D") +  # Viridis palette
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Vessel Type Categories pr. Site (2/3)",
    fill = "Type Description"  # Updated legend title
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Plot 3: Third third of the sites
plot3_VS02 <- ggplot(data_third_third_VS02, aes(x = site_name, y = count, fill = type_description)) +
  geom_bar(stat = "identity", position = "dodge") +  # Position bars side by side
  scale_fill_viridis(discrete = TRUE, option = "D") +  # Viridis palette
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Vessel Type Categories pr. Site (3/3)",
    fill = "Type Description"  # Updated legend title
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#Print the three plots

```{r, echo=TRUE}
# Print plot1_VS
plot1_VS02
```

```{r, echo=TRUE}
# Print plot2_VS
plot2_VS02
```

```{r, echo=TRUE}
# Print plot3_VS
plot3_VS02
```
OK! These three plots look nice! 

- I need to plot each site before showing these three plots
- I need to change the name of Togue Doupville-Galia to T. Doupville-Galia in the spreadsheet for better fit

# Interpretaiton of the 02_timelinedata results

- When there are many of one vessel type pr. site: 
  -> does that mean that the site was quite highly specialized like Pegue A and Dangandouloun that has a lot of the 15 Tellem tripods?
  -> does it mean that the site was early and only had a few pottery shapes available?
  -> does it mean that the site was specialized as hunting stations or seasonal?
  -> is it because the site has a short life span or narrow dating?
  
- When there are many of several vessels pr. site:
  -> does that mean that the site was a hub or "urban" site? (eg. many different cultural groups bring their own pottery types with them)
  -> does it mean that the site had developed a large array of pottery types "in situ" because it was dominant? (to "monopolize" the area culturally)
  -> does it mean that many different productions (metal, cloth, pottery, etc.) were situated at the site?
  -> is it because the site had a long life span or broad dating?
  
- When there are a lot of specific types pr. site
  -> when there are many of the multi purpose vessels (cat. 2, 4, 5) does this indicate settlements?
  -> When there are many of the wide open vessels (cat. 1 / cat. 8 carinated) does this indicate many feasts to display food, i.e. urban sites?
  -> when there are many storage pots (cat. 6, 9, 10, 11) does this also indicate urban hubs or huge settlements?
  -> when there are many vertical oval vessels (cat. 9, 10, 11) that need stabilization, does that mean a change in storage technology? 
      Or does it indicate that the site was more sedentary?
      Or a change in culture?
      Or change in climate to hotter?

------------------------------------------
# STEP 8: Plot of rim type counts per site
------------------------------------------

This step explores which rim type is dominant per site. 

It follows the same method as the previous step regarding vessel types.

# STEP 0: View rim types in the spreadsheet

This step is just to see if there are typos or other

```{r, echo=TRUE}
# View unique rim types
unique_rim_types <- unique(ceramics_subset$rim_category)
print(unique_rim_types)
```
Looks fine!

# STEP 01: Plot each site individually with rim type counts

OBS: "RS01" which is the addition to the data tables I produce refers to "Rim - Site" and data table 01 (ex: data_count_RS01)

```{r, echo=TRUE}
# Load required libraries
# library(ggplot2)
# library(dplyr)
# library(viridis)

# Count the occurrences of rim_category per site, excluding NA values
data_count_RS01 <- ceramics_subset %>%
  filter(!is.na(rim_category)) %>%  # Exclude rows with NA in rim_category
  group_by(site_name, rim_category) %>%
  summarise(count = n(), .groups = 'drop')

# Create a mapping of rim_category to descriptions (optional for additional info)
rim_description_map <- data.frame(
  rim_category = c("Sr", "Sp", "Sf", "Sb", "Es", "Ec", "Ecc", "Ef", "Efl", "Ep", 
                   "Et", "Esg", "Emg", "Vs", "Vc", "Oth", "Otc", "Otf", "Ith", 
                   "Itc", "Itf", "Th", "Tc", "Tf", "Ca", "I", "Y"),
  rim_description = c("Simple, rounded", "Simple, pointy", "Simple, flattened", 
                      "Simple, bevelled", "Everted, simple", "Everted, collared", 
                      "Everted, collared channelled", "Everted, flaring", 
                      "Everted, flattened", "Everted, protruding", 
                      "Everted, thickened", "Everted, single groove", 
                      "Everted, multiple groove", "Vertical, simple", "Vertical, collared", 
                      "Outward thickened, hinged", "Outward thickened, curved", 
                      "Outward thickened, flattened", "Inward thickened, hinged",
                      "Inward thickened, curved", "Inward thickened, flattened",
                      "Thickened, hinged", "Thickened, curved", "Thickened, flattened",
                      "Carinated", "Inverted", "Y-rims")
)

# Ensure `rim_category` columns are character for merging
data_count_RS01$rim_category <- as.character(data_count_RS01$rim_category)
rim_description_map$rim_category <- as.character(rim_description_map$rim_category)

# Merge the descriptions with the dataset
data_count_RS01 <- data_count_RS01 %>%
  left_join(rim_description_map, by = "rim_category")

# Ensure the x-axis and legend are dynamically ordered based on present rim types
data_count_RS01 <- data_count_RS01 %>%
  mutate(
    rim_category = factor(rim_category, levels = unique(data_count_RS01$rim_category)),
    rim_description = factor(rim_description, levels = unique(data_count_RS01$rim_description))
  )

# Create a function to generate a plot for a single site
plot_site_RS01 <- function(site_name) {
  site_data <- data_count_RS01 %>% filter(site_name == !!site_name)
  
  ggplot(site_data, aes(x = rim_category, y = count, fill = rim_description)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_viridis(discrete = TRUE, option = "D") +
    theme_minimal() +
    labs(
      title = paste("Rim Types at Site:", site_name),
      x = "Rim Category",
      y = "Count",
      fill = "Rim Type"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Get unique site names
site_names_RS01 <- unique(data_count_RS01$site_name)

# Generate and print plots for each site
for (site in site_names_RS01) {
  print(plot_site_RS01(site))
}

```

So, this is perfect! I need to interpret it later. You need to determine a specific colour to each rim type. Right now it changes in the plots. 

# STEP 02: Plot all the sites in three diagrams with the different rim types represented

OBS: "RS02" which is the addition to the data tables I produce refers to "Rim - Site" and datatable 02 (ex: data_count_RS02)

#Prepare data for three plots

```{r, echo=TRUE}
# Remove rows where rim_category is NA
data_count_RS02 <- ceramics_subset %>%
  filter(!is.na(rim_category)) %>%  # Drop NA values in rim_category
  group_by(site_name, rim_category) %>%
  summarise(count = n(), .groups = 'drop')

# Create a mapping of rim_category to rim descriptions (using abbreviations)
rim_descriptions_RS02 <- data.frame(
  rim_category = c("Sr", "Sp", "Sf", "Sb", "Es", "Ec", "Ecc", "Ef", "Efl", "Ep", 
                   "Et", "Esg", "Emg", "Vs", "Vc", "Oth", "Otc", "Otf", "Ith", 
                   "Itc", "Itf", "Th", "Tc", "Tf", "Ca", "I", "Y"),
  rim_description = c("Simple, rounded", "Simple, pointy", "Simple, flattened", 
                      "Simple, bevelled", "Everted, simple", "Everted, collared", 
                      "Everted, collared channelled", "Everted, flaring", 
                      "Everted, flattened", "Everted, protruding", 
                      "Everted, thickened", "Everted, single groove", 
                      "Everted, multiple groove", "Vertical, simple", "Vertical, collared", 
                      "Outward thickened, hinged", "Outward thickened, curved", 
                      "Outward thickened, flattened", "Inward thickened, hinged",
                      "Inward thickened, curved", "Inward thickened, flattened",
                      "Thickened, hinged", "Thickened, curved", "Thickened, flattened",
                      "Carinated", "Inverted", "Y-rims")
)

# Ensure both dataframes use character type for `rim_category`
data_count_RS02$rim_category <- as.character(data_count_RS02$rim_category)
rim_descriptions_RS02$rim_category <- as.character(rim_descriptions_RS02$rim_category)

# Merge descriptions into the data
data_count_RS02 <- data_count_RS02 %>%
  left_join(rim_descriptions_RS02, by = "rim_category")

# Ensure `rim_category` follows its abbreviation order (not numeric)
data_count_RS02 <- data_count_RS02 %>%
  mutate(rim_category = factor(rim_category, levels = rim_descriptions_RS02$rim_category),
         rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description))

# Pivot the data to wide format: Each rim_category becomes a separate column
data_wide_RS02 <- data_count_RS02 %>%
  select(-rim_description) %>% # Exclude rim_description for the wide format
  pivot_wider(names_from = rim_category, values_from = count, values_fill = list(count = 0))

# Reshape the data back to long format for plotting
data_long_RS02 <- data_wide_RS02 %>%
  pivot_longer(cols = -site_name, names_to = "rim_category", values_to = "count") %>%
  mutate(rim_category = factor(rim_category, levels = rim_descriptions_RS02$rim_category)) # Restore factor order

# Merge back the rim abbreviations for plotting instead of descriptions
data_long_RS02 <- data_long_RS02 %>%
  left_join(rim_descriptions_RS02, by = "rim_category") %>%
  mutate(rim_category = factor(rim_category, levels = rim_descriptions_RS02$rim_category)) # Use abbreviations for the legend

```

#Make data tables for three plots

```{r, echo=TRUE}

# Split the data into three groups based on site_name
third_size_RS02 <- floor(n_distinct(data_long_RS02$site_name) / 3)
site_names_first_third_RS02 <- unique(data_long_RS02$site_name)[1:third_size_RS02]
site_names_second_third_RS02 <- unique(data_long_RS02$site_name)[(third_size_RS02 + 1):(2 * third_size_RS02)]
site_names_third_third_RS02 <- unique(data_long_RS02$site_name)[(2 * third_size_RS02 + 1):length(unique(data_long_RS02$site_name))]

# Subset the data for each third of site names
data_first_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_first_third_RS02)

data_second_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_second_third_RS02)

data_third_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_third_third_RS02)

# Ensure numeric order for rim_category and include descriptions
data_first_third_RS02 <- data_first_third_RS02 %>%
  mutate(
    rim_category = factor(rim_category, levels = as.character(1:27)),
    rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description)
  )

data_second_third_RS02 <- data_second_third_RS02 %>%
  mutate(
    rim_category = factor(rim_category, levels = as.character(1:27)),
    rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description)
  )

data_third_third_RS02 <- data_third_third_RS02 %>%
  mutate(
    rim_category = factor(rim_category, levels = as.character(1:27)),
    rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description)
  )

```

#Plot the three plots

```{r, echo=TRUE}
# Plot 1: First third of the sites
plot1_RS02 <- ggplot(data_first_third_RS02, aes(x = site_name, y = count, fill = rim_description)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (1/3)",
    fill = "Rim Description"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#Print the plot
plot1_RS02

```

You need to make the legend smaller! Use the abrivations 

```{r, echo=TRUE}
# Plot 2: Second third of the sites
plot2_RS02 <- ggplot(data_second_third_RS02, aes(x = site_name, y = count, fill = rim_description)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (2/3)",
    fill = "Rim Description"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#Print the plot
plot2_RS02
```


```{r, echo=TRUE}
# Plot 3: Third third of the sites
plot3_RS02 <- ggplot(data_third_third_RS02, aes(x = site_name, y = count, fill = rim_description)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (3/3)",
    fill = "Rim Description"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#Print the plot
plot3_RS02
```
Ok, these plots need adjustments, but I now have a full plot of the rims pr site. I have some NAs from Karkarichinkat that I need to check out. Second, I need to decide if I really need the legend here, or if I can change it to the abbrivations

```{r, echo=TRUE}
library(dplyr)
library(stringr)
library(tidyr)
library(ggplot2)
library(viridis)

# Clean up rim_category in ceramics_subset: remove extra spaces and convert to upper case
ceramics_subset <- ceramics_subset %>%
  mutate(rim_category = toupper(trimws(rim_category)))

# Remove rows where rim_category is NA and count occurrences per site
data_count_RS02 <- ceramics_subset %>%
  filter(!is.na(rim_category)) %>%  
  group_by(site_name, rim_category) %>%
  summarise(count = n(), .groups = "drop")

# Create a mapping of rim_category to rim descriptions (using abbreviations) and clean the keys
rim_descriptions_RS02 <- data.frame(
  rim_category = toupper(c("Sr", "Sp", "Sf", "Sb", "Es", "Ec", "Ecc", "Ef", "Efl", "Ep", 
                           "Et", "Esg", "Emg", "Vs", "Vc", "Oth", "Otc", "Otf", "Ith", 
                           "Itc", "Itf", "Th", "Tc", "Tf", "Ca", "I", "Y")),
  rim_description = c("Simple, rounded", "Simple, pointy", "Simple, flattened", 
                      "Simple, bevelled", "Everted, simple", "Everted, collared", 
                      "Everted, collared channelled", "Everted, flaring", 
                      "Everted, flattened", "Everted, protruding", 
                      "Everted, thickened", "Everted, single groove", 
                      "Everted, multiple groove", "Vertical, simple", "Vertical, collared", 
                      "Outward thickened, hinged", "Outward thickened, curved", 
                      "Outward thickened, flattened", "Inward thickened, hinged",
                      "Inward thickened, curved", "Inward thickened, flattened",
                      "Thickened, hinged", "Thickened, curved", "Thickened, flattened",
                      "Carinated", "Inverted", "Y-rims"),
  stringsAsFactors = FALSE
)

# Ensure both data frames have rim_category as character
data_count_RS02 <- data_count_RS02 %>% mutate(rim_category = as.character(rim_category))
rim_descriptions_RS02$rim_category <- as.character(rim_descriptions_RS02$rim_category)

# Merge descriptions into the data using rim_category as the key
data_count_RS02 <- data_count_RS02 %>%
  left_join(rim_descriptions_RS02, by = "rim_category")

# Check the first few rows to ensure the join worked
print(head(data_count_RS02))

# Set factor levels based on the mapping order (using the abbreviations)
data_count_RS02 <- data_count_RS02 %>%
  mutate(
    rim_category = factor(rim_category, levels = rim_descriptions_RS02$rim_category),
    rim_description = factor(rim_description, levels = rim_descriptions_RS02$rim_description)
  )

# (Optional) Pivot to wide and back if needed for other analyses...
# For plotting, we can use data_count_RS02 directly, or if you have a split dataset,
# make sure it comes from this cleaned version.

```

# prepare three plots

```{r, echo=TRUE}
# Split the data into three groups based on site_name
# (We assume site_name ordering is the desired split)
total_sites <- length(unique(data_long_RS02$site_name))
third_size_RS02 <- floor(total_sites / 3)
site_names_first_third_RS02 <- unique(data_long_RS02$site_name)[1:third_size_RS02]
site_names_second_third_RS02 <- unique(data_long_RS02$site_name)[(third_size_RS02 + 1):(2 * third_size_RS02)]
site_names_third_third_RS02 <- unique(data_long_RS02$site_name)[(2 * third_size_RS02 + 1):total_sites]

# Subset the data for each group
data_first_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_first_third_RS02)

data_second_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_second_third_RS02)

data_third_third_RS02 <- data_long_RS02 %>%
  filter(site_name %in% site_names_third_third_RS02)

```

#Create the three plots

```{r, echo=TRUE}
# Create Plot 1: First third of the sites
plot1a_RS02 <- ggplot(data_first_third_RS02, aes(x = site_name, y = count, fill = rim_category)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (1/3)",
    fill = "Rim Type"  # Legend will display abbreviations
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Create Plot 2: Second third of the sites
plot2a_RS02 <- ggplot(data_second_third_RS02, aes(x = site_name, y = count, fill = rim_category)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (2/3)",
    fill = "Rim Type"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Create Plot 3: Third third of the sites
plot3a_RS02 <- ggplot(data_third_third_RS02, aes(x = site_name, y = count, fill = rim_category)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  labs(
    x = "Site Name",
    y = "Count",
    title = "Count of Rim Categories per Site (3/3)",
    fill = "Rim Type"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#Print plot 1

```{r, echo=TRUE}
plot1a_RS02
```

#Print plot 2

```{r, echo=TRUE}
plot2a_RS02
```

#Print plot 3

```{r, echo=TRUE}
plot3a_RS02
```
Ok, now I got the three plots with a proper legend. I am not sure if I can use it because there is too much data in one plot, and you cannot really differentiate the colors.. Perhaps I need more clear colours or something, but that is for later..

-------------------------------------
# STEP 9: Plot of base types per site
-------------------------------------

In the following I will explore which base types are dominant per site.

I use the abbrivation BS01 for Base - Site and the number is the database I create

```{r, echo=TRUE}

# Load required libraries
# library(ggplot2)
# library(dplyr)
# library(viridis)

# Count the occurrences of rim_category per site, excluding NA values
data_count_BS01 <- ceramics_subset %>%
  filter(!is.na(base_category)) %>%  # Exclude rows with NA in rim_category
  group_by(site_name, base_category) %>%
  summarise(count = n(), .groups = 'drop')

# Create a mapping of base_category to descriptions (optional for additional info)
base_description_map <- data.frame(
  base_category = c("Bf", "Br", "Bpe", "Bl", "Bc", "Bpo", "Sp", "Bro", "Bt"),
  base_description = c("Bases, flat", "Bases, ring", "Bases, pedestal", 
                      "Bases, legged", "Bases, concave", "Bases, pointy", "Special", 
                      "Bases, rounded", "Bases, tripod")
)

# Ensure `base_category` columns are character for merging
data_count_BS01$base_category <- as.character(data_count_BS01$base_category)
base_description_map$base_category <- as.character(base_description_map$base_category)

# Merge the descriptions with the dataset
data_count_BS01 <- data_count_BS01 %>%
  left_join(base_description_map, by = "base_category")

# Ensure the x-axis and legend are dynamically ordered based on present base types
data_count_BS01 <- data_count_BS01 %>%
  mutate(
    base_category = factor(base_category, levels = unique(data_count_BS01$base_category)),
    base_description = factor(base_description, levels = unique(data_count_BS01$base_description))
  )

# Create a function to generate a plot for a single site
plot_site_BS01 <- function(site_name) {
  site_data <- data_count_BS01 %>% filter(site_name == !!site_name)
  
  ggplot(site_data, aes(x = base_category, y = count, fill = base_description)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_viridis(discrete = TRUE, option = "D") +
    theme_minimal() +
    labs(
      title = paste("Base Types at Site:", site_name),
      x = "Base Category",
      y = "Count",
      fill = "Base Type"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Get unique site names
site_names_BS01 <- unique(data_count_BS01$site_name)

# Generate and print plots for each site
for (site in site_names_BS01) {
  print(plot_site_BS01(site))
}
```
Damn I'm good!

OBS: I will not try to put all the data into three diagrams before I know I will use it!

---------------------------------------
# STEP 10: Plot of vessel size per site
---------------------------------------

In the following I will explore which size cateogries are dominant per site

OBS I will use the SS abbreviations for Size - Site and then followed by a data number -> ex-SS01

```{r, echo=TRUE}

# Load required libraries
# library(ggplot2)
# library(dplyr)
# library(viridis)

# Count the occurrences of size_category per site, excluding NA values
data_count_SS01 <- ceramics_subset %>%
  filter(!is.na(size_category)) %>%  # Exclude rows with NA in size_category
  group_by(site_name, size_category) %>%
  summarise(count = n(), .groups = 'drop')

# Create a mapping of base_category to descriptions (optional for additional info)
size_description_map <- data.frame(
  size_category = c("a", "b", "c", "d", "e"),
  size_description = c("<14 cm", "15-24 cm", "25-34 cm", "35-44 cm", ">45 cm")
)

# Ensure `size_category` columns are character for merging
data_count_SS01$size_category <- as.character(data_count_SS01$size_category)
size_description_map$size_category <- as.character(size_description_map$size_category)

# Merge the descriptions with the dataset
data_count_SS01 <- data_count_SS01 %>%
  left_join(size_description_map, by = "size_category")

# Ensure the x-axis and legend are dynamically ordered based on present base types
data_count_SS01 <- data_count_SS01 %>%
  mutate(
    size_category = factor(size_category, levels = unique(data_count_SS01$size_category)),
    size_description = factor(size_description, levels = unique(data_count_SS01$size_description))
  )

# Create a function to generate a plot for a single site
plot_site_SS01 <- function(site_name) {
  site_data <- data_count_SS01 %>% filter(site_name == !!site_name)
  
  ggplot(site_data, aes(x = size_category, y = count, fill = size_description)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_viridis(discrete = TRUE, option = "D") +
    theme_minimal() +
    labs(
      title = paste("Size Categories at Site:", site_name),
      x = "Size Category",
      y = "Count",
      fill = "Size Type"
    ) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Get unique site names
site_names_SS01 <- unique(data_count_SS01$site_name)

# Generate and print plots for each site
for (site in site_names_SS01) {
  print(plot_site_SS01(site))
}
```
Damn I'm good!

OBS: I just noticed that the colors are not consistent, so the last category is always yellow for an example. I need to change this so the colors and types are consistent. This applies to all my previous plots!

---------------------------------------------------------
# STEP ??: Exploring the development of size through time
---------------------------------------------------------

#Q in Chad: 
"I have plotted my vessel in BC and AD terms (example: 250-100 BC, 150-300 AD) and I need to see the development of vessel sizes through time. How do I do this? Shall I change my BC terms in my spreadsheet to -250-100, or how?"

#A from Chad
To analyze the development of vessel sizes through time, it's essential to convert your BC and AD dates into a continuous numerical scale. This ensures that you can plot the data effectively and interpret trends over time. Here's how to handle it:

- 1. Convert BC and AD into a Continuous Scale

BC Dates: Represent BC dates as negative numbers. For example:
250–100 BC → -250 to -100

AD Dates: Represent AD dates as positive numbers. For example:
150–300 AD → 150 to 300

- 2. Adjust Your Spreadsheet

Create two columns in your spreadsheet for the start date and end date of each time range:
For 250–100 BC, enter -250 in the start column and -100 in the end column.
For 150–300 AD, enter 150 in the start column and 300 in the end column.

- 3. Calculate the Midpoint of Each Time Range

Add a new column for the midpoint (average) of the time range:

midpoint = ("start date" + "end date") / 2

For example:
For BC: -250 to -100: Midpoint = (−250+ −100)/2= -175
For AD: 150 to 300: Midpoint = (150+300)/2= 225

This will provide a single value for each vessel's time period, making it easier to analyze trends.

#OBS: All the above has been done, and I have uploaded the results as a spredsheet named "03_timelinedata"

- 4. Visualize Vessel Sizes Through Time

Use the midpoint column as the x-axis (time) and vessel size (e.g., height, diameter, or volume) as the y-axis.

Create a scatter plot, line plot, or boxplot using ggplot2 in R or your preferred plotting tool:

```{r, echo=TRUE}
ggplot(data, aes(x = midpoint, y = vessel_size)) +
  geom_point() + 
  geom_smooth(method = "loess", se = FALSE) +  # Optional trend line
  labs(title = "Development of Vessel Sizes Over Time",
       x = "Time (Years, BC/AD)",
       y = "Vessel Size") +
  theme_minimal()
```

- 5. Consider Trends

Look for patterns, such as increases or decreases in size over time or abrupt changes during specific periods.

Use color or shapes to differentiate vessel types, rim categories, or other attributes to add depth to the analysis.

---------------------------
# Mean, median, range, SD #
---------------------------

Calculating the mean + median + range + Standard Deviation (SD) for:

- actual diameter (orifice)
- actual height
- actual width

Mean: the mean, or average, is calculated by summing all the values in a dataset and then dividing that total by the number of values. It represents a central value of a dataset and is the most common measure of central tendency

Median: A median is the middle value in a dataset that has been arranged in order from smallest to largest. It divides the dataset in half, with 50% of the values being equal to or smaller than the median and 50% being equal to or larger than the median. To find the median, first sort the data, then identify the middle number for an odd number of data points, or calculate the average of the two middle numbers for an even number of data points. 

Range: In mathematics, the term "range" has two primary meanings: in statistics, it is the difference between the highest and lowest values in a dataset - To find the statistical range, you identify the largest and smallest numbers in a set and subtract the smallest from the largest.

SD: A standard deviation is a statistical measure of the amount of variation or dispersion within a set of data values, indicating how much individual data points typically deviate from the mean (average) of the set. A low standard deviation signifies that the data points tend to be close to the mean, while a high standard deviation indicates that the data points are spread out over a wider range of values.  

```{r, echo=TRUE}

# Descriptive statistics for key numeric variables
numeric_vars <- c("actual_width", "actual_diameter", "actual_height")

descriptive_stats <- ceramics_data %>%
  select(all_of(numeric_vars)) %>%
  summarise(
    across(everything(),
           list(
             mean = ~mean(.x, na.rm = TRUE),
             median = ~median(.x, na.rm = TRUE),
             min = ~min(.x, na.rm = TRUE),
             max = ~max(.x, na.rm = TRUE),
             sd = ~sd(.x, na.rm = TRUE)
           ),
           .names = "{.col}_{.fn}"
    )
  )

descriptive_stats

```

Interpretation:

